C51 COMPILER V9.53.0.0   PWM_SPEEDCONTROL                                                  04/09/2024 13:54:55 PAGE 1   


C51 COMPILER V9.53.0.0, COMPILATION OF MODULE PWM_SPEEDCONTROL
OBJECT MODULE PLACED IN .\Objects\PWM_SpeedControl.obj
COMPILER INVOKED BY: D:\Keil_v5\C51\BIN\C51.EXE ..\User\source\Function\PWM_SpeedControl.c LARGE OMF2 OPTIMIZE(8,SPEED) 
                    -BROWSE INCDIR(..\FU68xx_Hardware_Driver\Include;..\User\include) DEBUG PRINT(.\Listings\PWM_SpeedControl.lst) TABS(2) OB
                    -JECT(.\Objects\PWM_SpeedControl.obj)

line level    source

   1          /**
   2            ******************************************************************************
   3            * @file           : PWM_SpeedControl.c
   4            * @copyright      : (c) 2022, Fortior Tech
   5            * @brief          : 
   6            * @date           : 2023-02-14
   7            * @version        : 1.0.0
   8            *
   9            ******************************************************************************
  10            * @attention
  11            *
  12            * This software is licensed under terms that can be found in the LICENSE file
  13            * in the root directory of this software component.
  14            * If no LICENSE file comes with this software, it is provided AS-IS.
  15            *
  16            ******************************************************************************
  17            */  
  18          
  19          /* Includes ------------------------------------------------------------------*/
  20          #include <FU68xx_4.h>
  21          #include "MyProject.h"
  22          
  23          #if (HPFCOL_Enable == 1)
               #include "HPFCOL_Function.h"
              #endif
  26          
  27          /* Private includes ----------------------------------------------------------*/
  28          #include "PWM_SpeedControl.h"
  29          
  30          /* Private typedef -----------------------------------------------------------*/
  31          
  32          
  33          /* Private define ------------------------------------------------------------*/
  34          #define Motor_rawSpeedCurve(_S1_, _S0_, _D1_, _D0_)   ((float)(RPM2SpeedFlt((_S1_)) - RPM2SpeedFlt((_S0_))
             -) / (float)((_D1_) - (_D0_)))
  35          
  36          
  37          
  38          /* Private macro -------------------------------------------------------------*/
  39          
  40          
  41          /* Private variables ---------------------------------------------------------*/
  42          const uint16 PWMCurve_dutyArray[MOTOR_PWMMODE_NODENUM]  = MOTOR_PWMMODE_NODEDUTY;
  43          const uint16 PWMCurve_speedArray[MOTOR_PWMMODE_NODENUM] = MOTOR_PWMMODE_NODESPEED;
  44          PWMCapture_TyperDef mcPWM_Input;
  45          
  46          /* Private function prototypes -----------------------------------------------*/
  47          
  48          /* Private user code ---------------------------------------------------------*/
  49          
  50          
  51          /**
  52            * @brief    PWM 工作週期與頻率捕獲函數。
C51 COMPILER V9.53.0.0   PWM_SPEEDCONTROL                                                  04/09/2024 13:54:55 PAGE 2   

  53            * @retval   None
  54            */
  55          void PWM_capture(void)
  56          {
  57   1        if (mcPWM_Input.isBusy == 0)
  58   1        {
  59   2          mcPWM_Input.Compare = TIM3__DR;
  60   2          mcPWM_Input.Cycle   = TIM3__ARR;
  61   2          mcPWM_Input.isBusy  = 1;
  62   2          
  63   2          #if (WIDEBAND_PWM_Enable == 1)
                  {
                    if (mcPWM_Input.wideBand_Flag == 1 && mcPWM_Input.Cycle < 1050)
                    {
                      if (mcPWM_Input.wideBand_CNT > 10)
                      {
                        mcPWM_Input.wideBand_CNT  = 0;
                        mcPWM_Input.wideBand_Flag = 0;
                        SetReg(TIM3_CR0, T3PSC0 | T3PSC1 | T3PSC2, T3PSC0 | T3PSC1 | T3PSC2);
                        mcPWM_Input.isBusy  = 0;
                      }
                      else
                      {
                        mcPWM_Input.wideBand_CNT++;
                      }
                    }
                    else if (mcPWM_Input.wideBand_Flag == 1 && mcPWM_Input.wideBand_CNT != 0)
                    {
                      mcPWM_Input.wideBand_CNT--;
                    }
                  }
                  #endif
  85   2        }
  86   1      }
  87          
  88             
  89          /**
  90            * @brief    PWM 捕獲溢位檢測函數。
  91            * @retval   None
  92            */
  93          void PWM_overFlowDetection(void)
  94          {
  95   1        if (ReadBit(P0, PIN1))
  96   1        {
  97   2          mcPWM_Input.Compare = 3000;
  98   2          mcPWM_Input.Cycle   = 3000;
  99   2        }
 100   1        else
 101   1        {
 102   2          mcPWM_Input.Compare = 0;
 103   2          mcPWM_Input.Cycle   = 3000;
 104   2        }
 105   1        
 106   1        mcPWM_Input.isBusy = 1;
 107   1        
 108   1        
 109   1        #if (WIDEBAND_PWM_Enable == 1)
                {
                  if (mcPWM_Input.wideBand_Flag == 0)
                  {
                    SetReg(TIM3_CR0, T3PSC0 | T3PSC1 | T3PSC2, T3PSC2);
                    mcPWM_Input.wideBand_Flag = 1;
C51 COMPILER V9.53.0.0   PWM_SPEEDCONTROL                                                  04/09/2024 13:54:55 PAGE 3   

                    mcPWM_Input.isBusy = 0;
                  }
                }
                #endif
 119   1      }
 120          
 121          /* -------------------------------------------------------------------------------------------------
 122              Function Name  : VSPShutDown_Function
 123              Description    : VSP 輸入偵測停轉副程式
 124              Date           : 
 125              Parameter      : None
 126          ------------------------------------------------------------------------------------------------- */
 127          void VSPShutDown_Function(void)
 128          {
 129   1        if(mcVspInput.ADC7_LPF_Value >= Start_VSP_Voltage)
 130   1        {
 131   2          mcVspInput.VSP_Off_Filter_Count = 0;
 132   2          mcVspInput.VSP_On_Filter_Count++;
 133   2          if (mcVspInput.VSP_On_Filter_Count >= MotorOnFilterTime)
 134   2          {
 135   3            mcVspInput.VSP_On_Filter_Count = 0;
 136   3            mcVspInput.OnOff_Flag = 1;
 137   3          }
 138   2        }
 139   1        else
 140   1        {
 141   2          mcVspInput.VSP_On_Filter_Count = 0;
 142   2        }
 143   1      
 144   1        if(mcVspInput.ADC7_LPF_Value < Stop_VSP_Voltage)
 145   1        {
 146   2          mcVspInput.VSP_On_Filter_Count = 0;
 147   2          mcVspInput.VSP_Off_Filter_Count++;
 148   2          if (mcVspInput.VSP_Off_Filter_Count >= MotorOffFilterTime)
 149   2          {
 150   3            mcVspInput.VSP_Off_Filter_Count = 0;
 151   3            mcSpeedRamp.TargetValue = 0;
 152   3            mcSpeedRamp.ActualValue = 0;
 153   3            MOE = 0;
 154   3            mcVspInput.OnOff_Flag = 2;
 155   3          }
 156   2        }
 157   1        else
 158   1        {
 159   2          mcVspInput.VSP_Off_Filter_Count = 0;
 160   2        }
 161   1        
 162   1        if(mcVspInput.OnOff_Flag == 1)
 163   1        {
 164   2          mcSpeedRamp.FlagONOFF = 1;
 165   2        }
 166   1        else if(mcVspInput.OnOff_Flag == 2)
 167   1        {
 168   2          mcSpeedRamp.FlagONOFF = 0;
 169   2        }  
 170   1      }
 171          
 172          /*---------------------------------------------------------------------------*/
 173          /* Name   : void VSP_speedControl(void)
 174          /* Input  : NO
 175          /* Output : NO
 176          /* Description: 輸入VSP處理
C51 COMPILER V9.53.0.0   PWM_SPEEDCONTROL                                                  04/09/2024 13:54:55 PAGE 4   

 177          /*---------------------------------------------------------------------------*/
 178          void VSP_speedControl(void)
 179          { 
 180   1        LPF_MDU(ADC7_DR, 10, mcVspInput.ADC7_LPF_Value, mcVspInput.ADC7_LPF_LSB);
 181   1        mcVspInput.ADC7_Value = 32767 - mcVspInput.ADC7_LPF_Value;
 182   1        
 183   1        VSPShutDown_Function();
 184   1        
 185   1        if(mcSpeedRamp.FlagONOFF==1)
 186   1        {
 187   2          if(mcVspInput.ADC7_Value <= Max_VSP_Voltage)
 188   2          {
 189   3            mcSpeedRamp.TargetValue = (uint16)(Motor_Min_Speed + (VSP_Slope * (mcVspInput.ADC7_Value - (Min_VSP_
             -Voltage))));
 190   3      
 191   3            if(mcVspInput.ADC7_Value < Min_VSP_Voltage)
 192   3            {
 193   4              mcSpeedRamp.TargetValue = Motor_Min_Speed;
 194   4            }
 195   3          }
 196   2          else
 197   2          {
 198   3            mcSpeedRamp.TargetValue = Motor_Max_Speed;
 199   3          }
 200   2        }
 201   1        else
 202   1        {
 203   2          mcSpeedRamp.TargetValue = 0;
 204   2        }
 205   1      }
 206          
 207          /**
 208            * @brief    PWM 調速控制函數。
 209            * @retval   None
 210            */
 211          void PWM_speedControl(void)
 212          {
 213   1        uint16 MotorSpeedVSP;
 214   1        uint16 NodeNUM = 0;
 215   1        if (mcPWM_Input.isBusy == 1)
 216   1        {
 217   2          mcPWM_Input.Duty = _Q15((float)(mcPWM_Input.Compare) / (float)mcPWM_Input.Cycle);
 218   2          
 219   2          #if (HPFCOL_Enable == 1)
                  {
                    mcPWM_Input.Duty = HPFCOL_SpeedControl(mcPWM_Input.Duty);
                  }
                  #endif
 224   2          
 225   2          /*PWM 倒相控制 --開始*/
 226   2          #if (PWM_INVERT_Enable == 0)
                  {
                    MotorSpeedVSP = mcPWM_Input.Duty;
                  }
                  #elif(PWM_INVERT_Enable == 1)
 231   2          {        
 232   3            MotorSpeedVSP = (32767 - mcPWM_Input.Duty);
 233   3          }
 234   2          #endif
 235   2          /*PWM 倒相控制 --結束*/
 236   2          
 237   2          
C51 COMPILER V9.53.0.0   PWM_SPEEDCONTROL                                                  04/09/2024 13:54:55 PAGE 5   

 238   2          #if (AC_Lose_Function_Enable == 1)
 239   2          {
 240   3            DELL_coastMode_IC_Event(MotorSpeedVSP);
 241   3          }
 242   2          #endif
 243   2          
 244   2          if (MotorSpeedVSP <= PWMCurve_dutyArray[0])
 245   2          {
 246   3            mcSpeedRamp.TargetValue = RPM2SpeedFlt(PWMCurve_speedArray[0]);
 247   3          }
 248   2          else if (MotorSpeedVSP < PWMCurve_dutyArray[MOTOR_PWMMODE_NODENUM - 1])
 249   2          {
 250   3            for (NodeNUM = 1; NodeNUM < MOTOR_PWMMODE_NODENUM; NodeNUM++)
 251   3            {
 252   4              if (MotorSpeedVSP > PWMCurve_dutyArray[NodeNUM - 1] && MotorSpeedVSP <= PWMCurve_dutyArray[NodeNUM
             -])
 253   4              {
 254   5                mcSpeedRamp.TargetValue = RPM2SpeedFlt(PWMCurve_speedArray[NodeNUM - 1]) + Motor_rawSpeedCurve(P
             -WMCurve_speedArray[NodeNUM], PWMCurve_speedArray[NodeNUM - 1], PWMCurve_dutyArray[NodeNUM], PWMCurve_dutyArray[NodeNUM -
             - 1]) * (MotorSpeedVSP - PWMCurve_dutyArray[NodeNUM - 1]);
 255   5              }
 256   4            }
 257   3          }
 258   2          else
 259   2          {
 260   3            mcSpeedRamp.TargetValue = RPM2SpeedFlt(PWMCurve_speedArray[MOTOR_PWMMODE_NODENUM - 1]);
 261   3          }
 262   2        
 263   2          /*PWM 開關機控制 --開始*/
 264   2          #if (MOTOR_SHUTDOWN_Enable == 1)
                  {
                    if ((MotorSpeedVSP < PWMDUTY_TURNOFF && PWMDUTY_TURNOFF < PWMDUTY_TURNON) || (MotorSpeedVSP > PWMDUT
             -Y_TURNOFF && PWMDUTY_TURNOFF > PWMDUTY_TURNON))
                    {
                      mcPWM_Input.turnOn_CNT = 0;
                      if (mcPWM_Input.turnOff_CNT++ >= 20)
                      {
                        mcPWM_Input.turnOff_CNT = 0;
                        mcSpeedRamp.FlagONOFF = 0;
                        Open_TailWind_Count = 0;
                        mcSpeedRamp.TargetValue = 0;
                        mcSpeedRamp.ActualValue = 0;
                        Open_TailWind_Flag = 0;
                      }
                    }
                    else if ((MotorSpeedVSP > PWMDUTY_TURNON && PWMDUTY_TURNOFF < PWMDUTY_TURNON) || (MotorSpeedVSP < PW
             -MDUTY_TURNON && PWMDUTY_TURNOFF > PWMDUTY_TURNON))
                    {
                      mcPWM_Input.turnOff_CNT = 0;
                      if (mcPWM_Input.turnOn_CNT++ >= 10)
                      {
                        mcPWM_Input.turnOn_CNT = 0;
                        mcSpeedRamp.FlagONOFF = 1;
                      }
                    }
                  }
                  #endif
 290   2          /*PWM 開關機控制 --結束*/
 291   2          
 292   2          mcPWM_Input.isBusy = 0;
 293   2        }
 294   1      }
C51 COMPILER V9.53.0.0   PWM_SPEEDCONTROL                                                  04/09/2024 13:54:55 PAGE 6   



MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   1066    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =     62       4
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
   EDATA SIZE       =   ----    ----
   HDATA SIZE       =   ----    ----
   XDATA CONST SIZE =   ----    ----
   FAR CONST SIZE   =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)

C51 COMPILER V9.53.0.0   MOTORCONTROL                                                      04/09/2024 13:54:54 PAGE 1   


C51 COMPILER V9.53.0.0, COMPILATION OF MODULE MOTORCONTROL
OBJECT MODULE PLACED IN .\Objects\MotorControl.obj
COMPILER INVOKED BY: D:\Keil_v5\C51\BIN\C51.EXE ..\User\source\Function\MotorControl.c LARGE OMF2 OPTIMIZE(8,SPEED) BROW
                    -SE INCDIR(..\FU68xx_Hardware_Driver\Include;..\User\include) DEBUG PRINT(.\Listings\MotorControl.lst) TABS(2) OBJECT(.\O
                    -bjects\MotorControl.obj)

line level    source

   1          /* --------------------------- (C) COPYRIGHT 2020 Fortiortech ShenZhen -----------------------------
   2              File Name      : MotorControl.c
   3              Author         : Fortiortech  Appliction Team
   4              Version        : V1.0
   5              Date           : 2020-04-10
   6              Description    : This file contains .C file function used for Motor Control.
   7          ----------------------------------------------------------------------------------------------------  
   8                                                 All Rights Reserved
   9          ------------------------------------------------------------------------------------------------- */
  10          #include "FU68xx_4.h"
  11          #include "MyProject.h"
  12          
  13          #if (ROTATESIGNAL_TYPE != NO_TYPE)
  14           #include "SignalOutputControl.h"
  15          #endif
  16          
  17          /* Private variables ----------------------------------------------------------------------------*/
  18          MotStaType mcState;
  19          MotStaM    McStaSet;
  20          
  21          uint16 TimeCnt;
  22          
  23          #if (MOTOR_STARTDELAY_Enable == 1)
              uint16 Align_HistoryCNT = 0;
              uint8  StartDelay_Flag  = 0;
              #endif
  27          
  28          /* -------------------------------------------------------------------------------------------------
  29              Function Name  : MC_Control
  30              Description    : 电机控制状态机
  31              Date           : 2020-04-10
  32              Parameter      : None
  33          ------------------------------------------------------------------------------------------------- */
  34          void MC_Control(void)
  35          {
  36   1        
  37   1        #if (AC_Lose_Function_Enable == 1)
  38   1        {
  39   2          if (DELL_coastMode_State())
  40   2          {
  41   3            mcFocCtrl.State_Count = 500;
  42   3            mcState = mcStop;
  43   3          }
  44   2        }
  45   1        #endif
  46   1          
  47   1        
  48   1        if (mcFaultSource.Source != NoFault)
  49   1        {
  50   2          mcState = mcFault;
  51   2        }
  52   1        switch(mcState)
  53   1        {
C51 COMPILER V9.53.0.0   MOTORCONTROL                                                      04/09/2024 13:54:54 PAGE 2   

  54   2          case mcReady:
  55   2          {
  56   3          if (mcSpeedRamp.FlagONOFF == 0)
  57   3          {
  58   4            mcState = mcStop;
  59   4          }
  60   3          else
  61   3          {       
  62   4            Motor_Ready();
  63   4            
  64   4            if ((mcCurOffset.OffsetFlag == 1) && (mcSpeedRamp.FlagONOFF == 1)) 
  65   4            {
  66   5              mcCurOffset.OffsetFlag  = 0;
  67   5              mcState = mcInit; 
  68   5            }
  69   4          }
  70   3          break;
  71   3        }
  72   2          case mcInit:
  73   2          {
  74   3          if (mcSpeedRamp.FlagONOFF == 0)
  75   3          {
  76   4            mcState = mcStop;
  77   4          }
  78   3          else
  79   3          {
  80   4            Motor_Init();
  81   4            #if (TailWindEnable == 0)
                    {
                      #if (MOTOR_ALIGN_Enable == 1)
                      {
                        mcState = mcAlign;
                        Align_Calib.Counter = ALIGN_TIME;
                      }
                      #elif (MOTOR_ALIGN_Enable == 0)
                      {
                        mcState = mcStart;
                      }
                      #endif
                    }
                    #elif (TailWindEnable == 1)
  95   4            {
  96   5              mcState = mcTailWind;
  97   5            }
  98   4            #endif
  99   4          }
 100   3          }
 101   2        break;
 102   2          case mcTailWind:
 103   2        {
 104   3      
 105   3          if (mcSpeedRamp.FlagONOFF == 0)
 106   3          {
 107   4            mcState = mcStop;
 108   4          }
 109   3          else
 110   3          {
 111   4            Motor_TailWind();     
 112   4            if (mcFocCtrl.StartStaFlag == 1)
 113   4            {
 114   5              mcState = mcRun;
 115   5            }
C51 COMPILER V9.53.0.0   MOTORCONTROL                                                      04/09/2024 13:54:54 PAGE 3   

 116   4          }
 117   3          }
 118   2          break;
 119   2          case mcAlign:
 120   2          {
 121   3          if (mcSpeedRamp.FlagONOFF == 0)
 122   3          {
 123   4            mcState = mcStop;
 124   4          }
 125   3          else
 126   3          {
 127   4            #if (TailWindEnable == 1)
 128   4            {
 129   5              BEMFDetect.BEMF_Function_Count = 0;
 130   5              ClrBit(CMP_CR0, CMP2IM1 | CMP2IM0 | CMP1IM1 | CMP1IM0 | CMP0IM1 | CMP0IM0);
 131   5              ClrBit(CMP_CR2, CMP0EN);
 132   5            }
 133   4            #endif
 134   4            
 135   4            #if (MOTOR_STARTDELAY_Enable == 1)
                    {
                      if (Motor_DelayStart_CNT == 0)
                      {
                        if (StartDelay_Flag == 0)
                        {
                          mcState = mcReady;
                        }
                        else
                        {
                          Motor_Align();
                        }
                        StartDelay_Flag = 1;
                      }
                      else
                      {
                        #if (MOTOR_BRAKE_MODE == ALWAYSBRAKE || MOTOR_BRAKE_MODE == ONLYSTARTBRAKE)
                        {
                          if (McStaSet.SetFlag.StartBreakFlag == 0)
                          {
                            FOC_CR1 = 0x00;
                            ClrBit(DRV_CR, FOCEN);
                            DRV_DR   = DRV_ARR + 1;
                            DRV_CMR  = 0x00;
                            DRV_CMR |= 0x015;
                            ClrBit(DRV_CR, OCS);
                            SetBit(DRV_CR, DRVEN);
                            MOE = 1;
                            McStaSet.SetFlag.StartBreakFlag = 1;
                          }
                          
                        }
                        #endif
                        // do something.
                      }
                    }
                    #elif (MOTOR_STARTDELAY_Enable == 0)
 172   4            {
 173   5              Motor_Align();
 174   5            }
 175   4            #endif
 176   4            
 177   4            #if (AlignTestMode == 1)
C51 COMPILER V9.53.0.0   MOTORCONTROL                                                      04/09/2024 13:54:54 PAGE 4   

                    {
                      while(1);
                    }
                    #endif
 182   4          }
 183   3            break;
 184   3          }
 185   2          
 186   2          case mcStart:
 187   2          {
 188   3          if (mcSpeedRamp.FlagONOFF == 0)
 189   3          {
 190   4            mcState = mcStop;
 191   4          }
 192   3          else
 193   3          {
 194   4            Motor_Open();
 195   4          }
 196   3          }
 197   2          break;
 198   2          case mcRun:
 199   2          {
 200   3          if ((mcSpeedRamp.TargetValue == 0) || (mcSpeedRamp.FlagONOFF == 0))
 201   3          {
 202   4            mcState = mcStop;
 203   4            FOC_IQREF = 0;
 204   4            mcFocCtrl.State_Count = 1000;
 205   4          }
 206   3          }
 207   2          break;
 208   2          case mcStop:
 209   2          {
 210   3          if (McStaSet.SetFlag.StopSetFlag == 0)
 211   3          {
 212   4            McStaSet.SetFlag.StopSetFlag = 1;
 213   4            #if (MOTOR_BRAKE_MODE == ALWAYSBRAKE || MOTOR_BRAKE_MODE == ONLYSTOPBRAKE)
                    {
                      McStaSet.SetFlag.brakeSetFlag = 1;
                      ClrBit(DRV_CR, DRVEN);
                      MOE = 0;
                      FOC_CR1 = 0x00;
                      ClrBit(DRV_CR, FOCEN);
                      DRV_DR   = (DRV_ARR + 1);
                      DRV_CMR  = 0x00;
                      DRV_CMR |= 0x015;
                      ClrBit(DRV_CR, OCS);
                      SetBit(DRV_CR, DRVEN);
                      MOE = 1;
                    }
                    #else
 228   4            {
 229   5              FOC_CR1 = 0x00;
 230   5              ClrBit(DRV_CR, FOCEN);
 231   5              ClrBit(DRV_CR, DRVEN);
 232   5              MOE = 0;
 233   5            }
 234   4            #endif
 235   4          }
 236   3          
 237   3          if(mcSpeedRamp.FlagONOFF == 1 && mcFocCtrl.State_Count == 0)
 238   3          {
 239   4            BEMFDetect.BEMFBrakeFlag = 0;
C51 COMPILER V9.53.0.0   MOTORCONTROL                                                      04/09/2024 13:54:54 PAGE 5   

 240   4            SetBit(DRV_CR , DRVEN);
 241   4            DRV_DR  = 0;
 242   4            mcState = mcReady;
 243   4          }
 244   3          }
 245   2          break;
 246   2          case mcBrake: break;
 247   2          case mcFault:
 248   2          {
 249   3          if (mcFocCtrl.FaultStopFlag == 0)
 250   3          {
 251   4            FaultProcess();
 252   4            mcFocCtrl.FaultStopFlag = 1;
 253   4          }
 254   3          ClrBit(CMP_CR0, CMP2IM1 | CMP2IM0 | CMP1IM1 | CMP1IM0 | CMP0IM1 | CMP0IM0);
 255   3          ClrBit(CMP_CR2, CMP0EN);
 256   3          _nop_();
 257   3            
 258   3          #if (MOTOR_BRAKE_MODE == ALWAYSBRAKE || MOTOR_BRAKE_MODE == ONLYSTOPBRAKE)
                  {
                    if(McStaSet.SetFlag.brakeSetFlag == 0)
                    {
                    McStaSet.SetFlag.brakeSetFlag = 1;
                    ClrBit(DRV_CR, DRVEN);
                    MOE = 0;
                    FOC_CR1 = 0x00;
                    ClrBit(DRV_CR, FOCEN);
                    
                    if (ADCSampling.DcBus_Flt < Volt2DcBus(6.5))
                    {
                      DRV_DR   = (DRV_ARR * 0.92);
                    }
                    else
                    {
                      DRV_DR   = (DRV_ARR + 1);
                    }
                    
                    DRV_CMR  = 0x00;
                    DRV_CMR |= 0x015;
                    ClrBit(DRV_CR, OCS);
                    SetBit(DRV_CR, DRVEN);
                    MOE = 1;
                    }
                  }
                  #endif
 285   3          if (mcFaultSource.Source == NoFault)
 286   3          {
 287   4            mcState = mcReady;
 288   4          }
 289   3            break;
 290   3          }
 291   2          default:
 292   2          break;
 293   2        }
 294   1      }
 295          


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    361    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =      4    ----
C51 COMPILER V9.53.0.0   MOTORCONTROL                                                      04/09/2024 13:54:54 PAGE 6   

   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
   EDATA SIZE       =   ----    ----
   HDATA SIZE       =   ----    ----
   XDATA CONST SIZE =   ----    ----
   FAR CONST SIZE   =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)

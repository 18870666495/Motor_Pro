C51 COMPILER V9.53.0.0   INTERRUPT                                                         04/09/2024 13:54:54 PAGE 1   


C51 COMPILER V9.53.0.0, COMPILATION OF MODULE INTERRUPT
OBJECT MODULE PLACED IN .\Objects\Interrupt.obj
COMPILER INVOKED BY: D:\Keil_v5\C51\BIN\C51.EXE ..\User\source\Application\Interrupt.c LARGE OMF2 OPTIMIZE(8,SPEED) BROW
                    -SE INCDIR(..\FU68xx_Hardware_Driver\Include;..\User\include) DEBUG PRINT(.\Listings\Interrupt.lst) TABS(2) OBJECT(.\Obje
                    -cts\Interrupt.obj)

line level    source

   1          /* --------------------------- (C) COPYRIGHT 2020 Fortiortech ShenZhen -----------------------------
   2              File Name      : Interrupt.c
   3              Author         : Fortiortech  Appliction Team
   4              Version        : V1.0
   5              Date           : 2020-04-10
   6              Description    : This file contains .C file function used for Motor Control.
   7          ----------------------------------------------------------------------------------------------------
   8                                                 All Rights Reserved
   9          ------------------------------------------------------------------------------------------------- */
  10          #include "FU68xx_4.h"
  11          #include "MyProject.h"
  12          
  13          #if (ROTATESIGNAL_TYPE != NO_TYPE)
  14           #include "SignalOutputControl.h"
  15          #endif
  16          
  17          #if (SPEED_MODE == PWMMODE)
               #include "PWM_SpeedControl.h"
              #endif
  20          
  21          #if (HPFCOL_Enable == 1)
               #include "HPFCOL_Function.h"
              #endif
  24          
  25          #if (AVC_TURBOFAN_Enable == 1)
               #include "turboFanFunction.h"
              #endif
  28          
  29          extern uint8 data g_1mTick;                   ///< 1msæ»´ç­”ä¿¡å·ï¼Œæ¯éš”1msåœ¨SYSTICKå®šæ—¶å™¨è¢«ç½®1ï¼
             -Œéœ€åœ¨å¤§å¾ªçŽ¯ä½¿ç”¨å¤„æ¸…é›¶
  30          uint16 xdata spidebug[4] = { 0 };
  31          
  32          void LVW_TSD_INT(void) interrupt 0  //LVW & TSD interrupt
  33          {
  34   1      
  35   1        if(TSDIF)
  36   1        {
  37   2          TSDIF = 0;
  38   2        }
  39   1      
  40   1      }
  41          
  42          
  43          /* -------------------------------------------------------------------------------------------------
  44              Function Name  : FO_INT
  45              Description    : FO_INT interruptï¼Œç¡¬ä»¶FOè¿‡æµä¿æŠ¤ï¼Œå…³æ–­è¾“å‡ºï¼Œä¸­æ–­ä¼˜å…ˆçº§æœ€é«˜
  46              Date           : 2020-04-10
  47              Parameter      : None
  48          ------------------------------------------------------------------------------------------------- */
  49          //void FO_INT(void) interrupt 1               // ç¡¬ä»¶FOè¿‡æµä¸­æ–­ï¼Œå…³é—­è¾“å‡º
  50          //{
  51          //  if(IF0)
  52          //  {
C51 COMPILER V9.53.0.0   INTERRUPT                                                         04/09/2024 13:54:54 PAGE 2   

  53          //    FaultProcess();                         // å…³é—­è¾“å‡º
  54          //    mcFaultSource = FaultHardOVCurrent;     // ç¡¬ä»¶è¿‡æµä¿æŠ¤
  55          //    mcState = mcFault;                      // çŠ¶æ€ä¸ºmcFault
  56          //    IF0 = 0;                                // clear P00 interrupt flag
  57          //  }
  58          //}
  59          
  60          
  61          /* -------------------------------------------------------------------------------------------------
  62              Function Name  : EXTERN_INT
  63              Description    : ç¡çœ å”¤é†’
  64              Date           : 2020-04-10
  65              Parameter      : None
  66          ------------------------------------------------------------------------------------------------- */
  67          void EXTERN_INT(void) interrupt 2
  68          {
  69   1      //    if(SleepSet.SleepFlag == 1)
  70   1      //    {
  71   1      //        SleepSet.SleepFlag = 0;
  72   1      //        SleepSet.SleepEn   = 1;
  73   1      //    }
  74   1      //    ClrBit(P1_IF, P11);
  75   1      }
  76          
  77          
  78          /* -------------------------------------------------------------------------------------------------
  79              Function Name  : DRV_ISR
  80              Description    : FOCä¸­æ–­(Drvä¸­æ–­),æ¯ä¸ªè½½æ³¢å‘¨æœŸæ‰§è¡Œä¸€æ¬¡ï¼Œç”¨äºŽå¤„ç†å“åº”è¾ƒé«˜çš„ç¨‹å
             -ºï¼Œä¸­æ–­ä¼˜å…ˆçº§ç¬¬äºŒã€‚DCENå¼€äº†å°±ä¼šäº§ç”Ÿä¸­æ–­ã€‚
  81              Date           : 2020-04-10
  82              Parameter      : None
  83          ------------------------------------------------------------------------------------------------- */
  84          void DRV_ISR(void) interrupt 3
  85          {
  86   1        if(ReadBit(DRV_SR, FGIF))
  87   1        {
  88   2          ClrBit(DRV_SR, FGIF);
  89   2        }
  90   1        if(ReadBit(DRV_SR, DCIF))
  91   1        {
  92   2          /** è»Ÿé«”éŽé›»æµæª¢æ¸¬å‡½æ•¸ **/
  93   2          Fault_softOverCurrent(&mcCurVarible);
  94   2          
  95   2          #if defined (SPI_DBG_SW)  //è½¯ä»¶è°ƒè¯•æ¨¡å¼
                  {
                    spidebug[0] = SOFT_SPIDATA0;
                    spidebug[1] = SOFT_SPIDATA1;
                    spidebug[2] = SOFT_SPIDATA2;
                    spidebug[3] = SOFT_SPIDATA3;
                  }
                  #endif
 103   2          
 104   2          #if (AC_Lose_Function_Enable == 1)
 105   2          {
 106   3            //dosomething.
 107   3          }
 108   2          #endif
 109   2          
 110   2        if(TailWindDetect.TailWindDetectInitFlag)
 111   2        {
 112   3          TailWindSpeedDetect();
 113   3        }
C51 COMPILER V9.53.0.0   INTERRUPT                                                         04/09/2024 13:54:54 PAGE 3   

 114   2      
 115   2          DRV_SR = (DRV_SR | SYSTIF) & (~DCIF);
 116   2        }
 117   1      }
 118          
 119          /* -------------------------------------------------------------------------------------------------
 120              Function Name  : TIM2_INT
 121              Description    :
 122              Date           : 2020-04-10
 123              Parameter      : None
 124          ------------------------------------------------------------------------------------------------- */
 125          void TIM2_INT(void) interrupt 4
 126          {
 127   1        if(ReadBit(TIM2_CR1, T2IR))
 128   1        {
 129   2          ClrBit(TIM2_CR1, T2IR);
 130   2        }
 131   1        if(ReadBit(TIM2_CR1, T2IP))
 132   1        {
 133   2          ClrBit(TIM2_CR1, T2IP);
 134   2        }
 135   1        if(ReadBit(TIM2_CR1, T2IF))
 136   1        {
 137   2          ClrBit(TIM2_CR1, T2IF);
 138   2        }
 139   1      }
 140          
 141          
 142          /* -------------------------------------------------------------------------------------------------
 143              Function Name  : CMP_ISR
 144              Description    : CMP0/1/2ï¼šé¡ºé€†é£Žåˆ¤æ–­
 145              Date           : 2020-04-10
 146              Parameter      : None
 147          ------------------------------------------------------------------------------------------------- */
 148          void CMP_ISR(void) interrupt 7
 149          {
 150   1        if(ReadBit(CMP_SR, CMP0IF) || ReadBit(CMP_SR, CMP1IF) || ReadBit(CMP_SR, CMP2IF)) //å½“æ£€æµ‹åˆ°æ¯”è¾ƒå™
             -¨ä¸­æ–­æ—¶
 151   1        {
 152   2          /* -----é€šè¿‡BEMFåšé¡ºé€†é£Žæ£€æµ‹åŠŸèƒ½----- */
 153   2          BEMFDetectFunc();
 154   2          ClrBit(CMP_SR, CMP0IF | CMP1IF | CMP2IF);
 155   2        }
 156   1      }
 157          
 158          /* -------------------------------------------------------------------------------------------------
 159              Function Name  : TIM3_INT
 160              Description    : PWM èª¿é€Ÿæª¢æ¸¬è¨ˆæ•¸å™¨ä¸­æ–·
 161              Date           : 2020-09-16
 162              Parameter      : None
 163          ------------------------------------------------------------------------------------------------- */
 164          uint8 AC_Lose_Zero_Flag = 0;
 165          uint8 AC_Lose_Zero_Count = 0;
 166          uint8 AC_Lose_Flag = 0;
 167          uint8 AC_Lose_Step = 0;
 168          uint16 AC_Lose_Power_Limit = 0;
 169          uint8 AC_Lose_Step_Flag = 0;
 170          uint8 AC_Lose_Step_Count = 0;
 171          uint8 AC_Lose_FG_Flag = 0;
 172          
 173          void TIM3_INT(void) interrupt 9
 174          {
C51 COMPILER V9.53.0.0   INTERRUPT                                                         04/09/2024 13:54:54 PAGE 4   

 175   1        #if (HPFCOL_Enable == 1)
                {
                  HPFCOL_CommDetection();
                }
                #endif
 180   1        
 181   1        if (ReadBit(TIM3_CR1, T3IR))
 182   1        {
 183   2          ClrBit(TIM3_CR1, T3IR);
 184   2        }
 185   1        if (ReadBit(TIM3_CR1, T3IP))
 186   1        {
 187   2          #if (SPEED_MODE == PWMMODE)
                  {
                    PWM_capture();
                  }
                  #endif
 192   2          ClrBit(TIM3_CR1, T3IP);
 193   2        }
 194   1        
 195   1        if (ReadBit(TIM3_CR1, T3IF))
 196   1        {
 197   2          #if (SPEED_MODE == PWMMODE)
                  {
                    PWM_overFlowDetection();
                  }
                  #endif
 202   2      
 203   2          #if (AC_Lose_Function_Enable == 1)
 204   2          {
 205   3            DELL_coastMode_IF_Event();
 206   3          }
 207   2          #endif
 208   2          ClrBit(TIM3_CR1, T3IF);
 209   2        }
 210   1      }
 211          
 212          
 213          /* -------------------------------------------------------------------------------------------------
 214              Function Name  : SYStick_INT
 215              Description    : 1mså®šæ—¶å™¨ä¸­æ–­ï¼ˆSYS TICKä¸­æ–­ï¼‰ï¼Œç”¨äºŽå¤„ç†é™„åŠ åŠŸèƒ½ï¼Œå¦‚æŽ§åˆ¶çŽ¯è·¯å“
             -åº”ã€å„ç§ä¿æŠ¤ç­‰ã€‚ä¸­æ–­ä¼˜å…ˆçº§ä½ŽäºŽFOä¸­æ–­å’ŒFOCä¸­æ–­ã€‚
 216              Date           : 2020-04-10
 217              Parameter      : None
 218          ------------------------------------------------------------------------------------------------- */
 219          int16 EK1 = 0;
 220          int16 EK2 = 0;
 221          int16 EK3 = 0;
 222          void SYStick_INT(void) interrupt 10
 223          {
 224   1        /* Sys Tick ä¸­æ–·å‡½æ•¸ -é–‹å§‹ */
 225   1        if(ReadBit(DRV_SR, SYSTIF))
 226   1        {
 227   2          /* é å®šä½å¼·åº¦é‡æ¸¬ -é–‹å§‹ */
 228   2        if (mcState == mcAlign)
 229   2          {
 230   3            if (McStaSet.SetFlag.AlignSetFlag == 1)
 231   3            {
 232   4              if (Align_Calib.Update_CNT != 0)
 233   4              {
 234   5                Align_Calib.Align_IA = FOC__IAMAX;
 235   5                Align_Calib.Align_IB = FOC__IBMAX;
C51 COMPILER V9.53.0.0   INTERRUPT                                                         04/09/2024 13:54:54 PAGE 5   

 236   5                Align_Calib.Align_IC = FOC__ICMAX;
 237   5                Align_Calib.Update_CNT--;
 238   5              }
 239   4              
 240   4              if (Align_Calib.Counter != 0)
 241   4              {
 242   5                Align_Calib.Counter--;
 243   5              }
 244   4            }
 245   3          }
 246   2          /* é å®šä½å¼·åº¦é‡æ¸¬ -çµæŸ */
 247   2          
 248   2          #if (MOTOR_STARTDELAY_Enable == 1)
                  {
                    if (Motor_DelayStart_CNT != 0)
                      Motor_DelayStart_CNT--;
                  }
                  #endif
 254   2          
 255   2          /* ä¿¡è™Ÿè¼¸å‡ºå‡½æ•¸ -é–‹å§‹ */
 256   2          #if (ROTATESIGNAL_TYPE == FG_TYPE)
 257   2          {
 258   3            SignalOutput_Counter();
 259   3          }
 260   2          #elif (ROTATESIGNAL_TYPE == RD_TYPE)
                  {
                    SignalOutput_Counter();
                  }
                  #endif
 265   2          /* ä¿¡è™Ÿè¼¸å‡ºå‡½æ•¸ -çµæŸ */
 266   2          
 267   2          /* HPFCOL è¨ˆæ•¸å‡½æ•¸ -é–‹å§‹ */
 268   2          #if (HPFCOL_Enable == 1)
                  {
                    HPFCOLCounter_Event();
                  }
                  #endif
 273   2          /* HPFCOL è¨ˆæ•¸å‡½æ•¸ -çµæŸ */
 274   2              
 275   2          /* 10 ç§’è¨ˆæ•¸å™¨ -é–‹å§‹ */
 276   2          if (mcFocCtrl.Millis < 10000 && mcFocCtrl.CtrlMode == 1)
 277   2          {
 278   3            mcFocCtrl.Millis++; 
 279   3          }
 280   2          /* 10 ç§’è¨ˆæ•¸å™¨ -çµæŸ */
 281   2          
 282   2          /*TurboFan æ™‚é–“è¨ˆæ•¸å‡½æ•¸ --é–‹å§‹*/
 283   2          #if (AVC_TURBOFAN_Enable == 1)
                  {
                    TurboFan_CountEvent();
                    Uart_CountEvent();
                  }
                  #endif
 289   2          /*TurboFan æ™‚é–“è¨ˆæ•¸å‡½æ•¸ --çµæŸ*/
 290   2          
 291   2          /* é›»æµé™åˆ¶å™¨ -é–‹å§‹ */
 292   2          #if (CURRENT_LIMITER_Enable == 1)
                  {
                    CurrentLimiter_Process();
                  }
                  #endif
 297   2          /* é›»æµé™åˆ¶å™¨ -çµæŸ */
C51 COMPILER V9.53.0.0   INTERRUPT                                                         04/09/2024 13:54:54 PAGE 6   

 298   2          
 299   2          
 300   2          
 301   2          #if (Slowdown_Response_Enable == 1)
 302   2          {
 303   3            Slowdown_Response_Function();
 304   3          }
 305   2          #endif
 306   2          
 307   2          #if (AC_Lose_Function_Enable == 1)
 308   2          {
 309   3            DELL_coastMode_Process();
 310   3            
 311   3            /* æœªçŸ¥åŠŸèƒ½ é ˆè©¢å• Kevin æ·»åŠ ç”¨æ„ --é–‹å§‹ */
 312   3            if(AC_Lose_Flag == 2)
 313   3            {
 314   4              PI3_UKMAX = AC_Lose_Limit_Power_Value;
 315   4            }
 316   3            else
 317   3            {
 318   4              #if ((CURRENT_LIMITER_Enable != 1) && (Watt_Limit_Enable != 1))
 319   4              {
 320   5                PI3_UKMAX = SOUTMAX;
 321   5              }
 322   4              #endif
 323   4            }
 324   3            /* æœªçŸ¥åŠŸèƒ½ é ˆè©¢å• Kevin æ·»åŠ ç”¨æ„ --çµæŸ */
 325   3          }
 326   2          #elif (AC_Lose_Function_Enable == 0)
                  {
                    
                    /* æœªçŸ¥åŠŸèƒ½ é ˆè©¢å• Kevin æ·»åŠ ç”¨æ„ --é–‹å§‹ */
                    #if ((CURRENT_LIMITER_Enable != 1) && (Watt_Limit_Enable != 1))
                    {
                      PI3_UKMAX = SOUTMAX;
                    }
                    #endif
                    /* æœªçŸ¥åŠŸèƒ½ é ˆè©¢å• Kevin æ·»åŠ ç”¨æ„ --çµæŸ */
                    
                  }
                  #endif
 339   2      
 340   2          SetBit(ADC_CR, ADCBSY);           // ä½¿èƒ½ ADC çš„ DCBUS é‡‡æ ·
 341   2          EK1 = FOC_EK1;
 342   2          EK2 = FOC_EK2;
 343   2          EK3 = FOC_EK3;
 344   2      
 345   2      
 346   2          mcFocCtrl.QoutValue     = FOC__UQ;
 347   2          mcFocCtrl.DoutValue     = FOC__UD;
 348   2      
 349   2          /* -----åŠŸçŽ‡æ»¤æ³¢----- */
 350   2          if(mcState == mcRun)
 351   2          {
 352   3            mcFocCtrl.CurrentPower = FOC__POW << 1;
 353   3            LPF_MDU(mcFocCtrl.CurrentPower, 10, mcFocCtrl.Powerlpf, mcFocCtrl.Powerlpf_LSB);//æ³¨æ„ä½Žé€šæ»¤æ³¢
             -å™¨ç³»æ•°èŒƒå›´ä¸º0---127
 354   3          }
 355   2          else
 356   2          {
 357   3            mcFocCtrl.Powerlpf = 0;
 358   3          }
C51 COMPILER V9.53.0.0   INTERRUPT                                                         04/09/2024 13:54:54 PAGE 7   

 359   2      
 360   2          /* -----é€Ÿåº¦æ»¤æ³¢----- */
 361   2          if((mcState == mcStart) || (mcState == mcRun))
 362   2          {
 363   3            LPF_MDU(FOC__EOME, 10, mcFocCtrl.SpeedFlt, mcFocCtrl.SpeedFlt_LSB);
 364   3          }
 365   2          else
 366   2          {
 367   3            mcFocCtrl.SpeedFlt = 0;
 368   3          }
 369   2      
 370   2          Atan_Us_MDU(FOC__EALP, FOC__EBET, mcFocCtrl.EsValue);
 371   2      
 372   2          Speed_response();
 373   2      
 374   2          #if (Watt_Limit_Enable == 1)
                  {
                    Watt_Limit_Function();
                  }
                  #endif
 379   2      
 380   2      
 381   2          /*****DCbusçš„é‡‡æ ·èŽ·å–å€¼å¹¶æ»¤æ³¢******/
 382   2          #if (HW_RV_MODE == RV6P5 || HW_RV_MODE == RV12)
                  {
                    ADCSampling.DcBus_SamplingValue = ADC14_DR;
                  }
                  #elif (HW_RV_MODE == RVEXT)
 387   2          {
 388   3            ADCSampling.DcBus_SamplingValue = ADC2_DR;
 389   3          }
 390   2          #endif
 391   2      
 392   2          LPF_MDU((ADCSampling.DcBus_SamplingValue) , 50, ADCSampling.DcBus_Flt, ADCSampling.DcBusFlt_Buff);
 393   2          //ADCSampling.DcBus_Flt = ADCSampling.DcBus_SamplingValue;
 394   2      
 395   2          
 396   2          /*----------------------------------------------------------------------------------------------------
             --*/
 397   2      
 398   2          /** é›»æ©Ÿä¿è­·è¼ªè©¢å‡½æ•¸ **/
 399   2          Fault_Detection();
 400   2      
 401   2          /*****ç”µæœºçŠ¶æ€æœºçš„æ—¶åºå¤„ç†*****/
 402   2          if(mcFocCtrl.State_Count > 0)
 403   2            mcFocCtrl.State_Count--;
 404   2          StarRampDealwith();
 405   2          if(BEMFDetect.BEMFTimeCount > 0)
 406   2            BEMFDetect.BEMFTimeCount--;
 407   2          if(BEMFDetect.BEMF_Function_Flag == 1)
 408   2          {
 409   3            BEMFDetect.BEMF_Function_Count++;
 410   3          }
 411   2          if(BEMFDetect.BEMF_Function_Flag == 2)
 412   2          {
 413   3              BEMFDetect.BEMFMotorStartLowSpeedFilter++;
 414   3          }   
 415   2          if((BEMFDetect.BEMF_Function_Time_Out_Flag == 1)&&(BEMFDetect.BEMF_Function_Time_Out_Count < 5000))
 416   2          {
 417   3            BEMFDetect.BEMF_Function_Time_Out_Count++;
 418   3          }
 419   2          DRV_SR = (DRV_SR | DCIF) & (~SYSTIF);
C51 COMPILER V9.53.0.0   INTERRUPT                                                         04/09/2024 13:54:54 PAGE 8   

 420   2          /* Sys Tick ä¸­æ–·å‡½æ•¸ -çµæŸ */
 421   2        }
 422   1      }
 423          
 424          
 425          void TIM4_INT(void) interrupt 11
 426          {
 427   1        #if (HPFCOL_Enable == 1)
                  HPFCOLUpdate_Event();
                #endif
 430   1        
 431   1        if (ReadBit(TIM4_CR1, T4IR))
 432   1        {
 433   2          ClrBit(TIM4_CR1, T4IR);
 434   2        }
 435   1        
 436   1        if (ReadBit(TIM4_CR1, T4IF))
 437   1        {
 438   2          #if (ROTATESIGNAL_TYPE == FG_TYPE)
 439   2          {
 440   3            FG_Update_Event();
 441   3          }
 442   2          #endif
 443   2          ClrBit(TIM4_CR1, T4IF);
 444   2        }
 445   1      }
 446          
 447          
 448          /* -------------------------------------------------------------------------------------------------
 449              Function Name  : CMP3_INT
 450              Description    : CMP3ï¼šç¡¬ä»¶æ¯”è¾ƒå™¨è¿‡æµä¿æŠ¤ï¼Œå…³æ–­è¾“å‡ºï¼Œä¸­æ–­ä¼˜å…ˆçº§æœ€é«˜
 451              Date           : 2020-04-10
 452              Parameter      : None
 453          ------------------------------------------------------------------------------------------------- */
 454          void CMP3_INT(void)  interrupt 12
 455          {
 456   1        if(ReadBit(CMP_SR, CMP3IF))
 457   1        {
 458   2          mcFaultSource.Source = Hard_OverCurrent;                                          // ç¡¬ä»¶è¿‡æµä¿æŠ
             -¤
 459   2        mcFocCtrl.FaultStopFlag = 0;
 460   2          ClrBit(CMP_SR, CMP3IF);
 461   2        }
 462   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   1235    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =     23    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
   EDATA SIZE       =   ----    ----
   HDATA SIZE       =   ----    ----
   XDATA CONST SIZE =   ----    ----
   FAR CONST SIZE   =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)

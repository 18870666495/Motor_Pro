C51 COMPILER V9.53.0.0   DMA                                                               04/09/2024 13:54:56 PAGE 1   


C51 COMPILER V9.53.0.0, COMPILATION OF MODULE DMA
OBJECT MODULE PLACED IN .\Objects\DMA.obj
COMPILER INVOKED BY: D:\Keil_v5\C51\BIN\C51.EXE ..\User\source\Hardware\DMA.c LARGE OMF2 OPTIMIZE(8,SPEED) BROWSE INCDIR
                    -(..\FU68xx_Hardware_Driver\Include;..\User\include) DEBUG PRINT(.\Listings\DMA.lst) TABS(2) OBJECT(.\Objects\DMA.obj)

line level    source

   1          /* --------------------------- (C) COPYRIGHT 2020 Fortiortech ShenZhen -----------------------------
   2              File Name      : DMA.c
   3              Author         : Fortiortech  Appliction Team
   4              Version        : V1.0
   5              Date           : 2020-04-11
   6              Description    : This file contains .C file function used for Motor Control.
   7          ----------------------------------------------------------------------------------------------------  
   8                                                 All Rights Reserved
   9          ------------------------------------------------------------------------------------------------- */
  10          #include "FU68xx_4.h"
  11          #include "MyProject.h"
  12          
  13          #define Switch_DMA(a)     SetBit(*(&DMA0_CR0 + a), DMAEN | DMABSY)
  14          
  15          void SetPipe_DMA0(eType_DMA_PIPE ePipe)
  16          {
  17   1          bool bTmp = false;
  18   1      
  19   1          if (ReadBit(DMA0_CR0 , DMAEN))
  20   1          {
  21   2              bTmp = true;
  22   2              while (ReadBit(DMA0_CR0 , DMABSY));
  23   2              ClrBit(DMA0_CR0 , DMAEN);
  24   2          }
  25   1      
  26   1          SetReg(DMA0_CR0 , DMACFG2 | DMACFG1 | DMACFG0 , ePipe);
  27   1      
  28   1          if (bTmp) SetBit(DMA0_CR0 , DMAEN);
  29   1      }
  30          
  31          void SetPipe_DMA1(eType_DMA_PIPE ePipe)
  32          {
  33   1          bool bTmp = false;
  34   1      
  35   1          if (ReadBit(DMA1_CR0 , DMAEN))
  36   1          {
  37   2              bTmp = true;
  38   2              while (ReadBit(DMA1_CR0 , DMABSY));
  39   2              ClrBit(DMA1_CR0 , DMAEN);
  40   2          }
  41   1      
  42   1          SetReg(DMA1_CR0 , DMACFG2 | DMACFG1 | DMACFG0 , ePipe);
  43   1      
  44   1          if (bTmp) SetBit(DMA1_CR0 , DMAEN);
  45   1      }
  46          
  47          void SetDataPackage_DMA0(unsigned short ulAddr , char cLen)
  48          {
  49   1          bool bTmp = false;
  50   1      
  51   1          if (ReadBit(DMA0_CR0 , DMAEN))
  52   1          {
  53   2              bTmp = true;
  54   2      
C51 COMPILER V9.53.0.0   DMA                                                               04/09/2024 13:54:56 PAGE 2   

  55   2              while (ReadBit(DMA0_CR0 , DMABSY));
  56   2              ClrBit(DMA0_CR0 , DMAEN);
  57   2          }
  58   1      
  59   1          DMA0_LEN =  cLen;
  60   1          DMA0_BA  =  ulAddr;
  61   1      
  62   1          if (bTmp) SetBit(DMA0_CR0, DMAEN);
  63   1      }
  64          
  65          void SetDataPackage_DMA1(unsigned short ulAddr, char cLen)
  66          {
  67   1          bool bTmp = false;
  68   1      
  69   1          if (ReadBit(DMA1_CR0 , DMAEN))
  70   1          {
  71   2              bTmp = true;
  72   2      
  73   2              while (ReadBit(DMA1_CR0 , DMABSY));
  74   2              ClrBit(DMA1_CR0 , DMAEN);
  75   2          }
  76   1      
  77   1          DMA1_LEN = cLen;
  78   1          DMA1_BA  = ulAddr;
  79   1      
  80   1          if (bTmp) SetBit(DMA1_CR0 , DMAEN);
  81   1      }
  82          
  83          void SetEndian_DMA(eType_DMA_Endian eEndian)
  84          {
  85   1          bool bTmp = false, bTmp1;
  86   1      
  87   1          if (ReadBit(DMA0_CR0 , DMAEN))
  88   1          {
  89   2              bTmp = true;
  90   2      
  91   2              while (ReadBit(DMA0_CR0 , DMABSY));
  92   2              ClrBit(DMA0_CR0 , DMAEN);
  93   2          }
  94   1      
  95   1          if (ReadBit(DMA1_CR0 , DMAEN))
  96   1          {
  97   2              bTmp1 = true;
  98   2      
  99   2              while (ReadBit(DMA1_CR0 , DMABSY));
 100   2              ClrBit(DMA1_CR0 , DMAEN);
 101   2          }
 102   1      
 103   1          SetReg(DMA0_CR0, ENDIAN, eEndian);
 104   1      
 105   1          if (bTmp)  SetBit(DMA0_CR0 , DMAEN);
 106   1          if (bTmp1) SetBit(DMA1_CR0 , DMAEN);
 107   1      }
 108          
 109          void SetIRQ_DMA(ebool eIRQ, eType_DMA_IRQ eIP)
 110          {
 111   1          SetReg(DMA0_CR0, DMAIE, eIRQ ? DMAIE : 0);
 112   1      
 113   1          if (!EA) EA = 1;
 114   1      
 115   1          if (eIRQ) SetReg(IP1 , PDMA1 | PDMA0 , eIP);
 116   1      }
C51 COMPILER V9.53.0.0   DMA                                                               04/09/2024 13:54:56 PAGE 3   

 117          
 118          void SetDbgMod_DMA(void)
 119          {
 120   1          bool bTmp = false;
 121   1      
 122   1          if (ReadBit(DMA1_CR0 , DMAEN))
 123   1          {
 124   2              bTmp = true;
 125   2      
 126   2              while (ReadBit(DMA1_CR0 , DMABSY));
 127   2              ClrBit(DMA1_CR0 , DMAEN);
 128   2          }
 129   1      
 130   1          SetBit(DMA1_CR0 , DBGEN);
 131   1          SetBit(DMA1_CR0 , ((eType_DMA_PIPE)DRAM_SPI));
 132   1          DMA1_LEN = 4;
 133   1      
 134   1          if (bTmp) SetBit(DMA1_CR0, DMAEN);
 135   1      }
 136          
 137          /**
 138           * ËÆæÁΩÆDMA1ÁöÑDBGÊ®°Âºè
 139           *
 140           * @param Addr   Ë¶ÅDBGËæìÂá∫ÁöÑÂú∞ÂùÄ
 141           */
 142          void Set_DBG_DMA(uint16 DMAAddr)
 143          {
 144   1          ClrBit(DMA1_CR0, DMAEN);                                // Á¶ÅÊ≠¢DMA1‰º†Ëæì
 145   1          SetBit(DMA1_CR0, DBGEN | DRAM_SPI);                     // ËÆæÁΩÆDMA1‰ΩøÁî®DBGÊ®°ÂºèÔºåXDATAÂèëÈÄÅÊï∞Ê
             -çÆÂà∞SPI
 146   1          if (!ReadBit(DMAAddr, 0x4000)) SetBit(DMA1_CR0, DBGSW); //Ê†πÊçÆDMAAddrÂà§Êñ≠ÊòØÂê¶Âú®XRAMÂå∫ÔºåÂ¶ÇÊûú
             -ÊòØÂàôÂºÄÂêØDBGSW
 147   1      
 148   1          DMA1_LEN = 7;                                           // ËÆæÁΩÆDMA1ÂèëÈÄÅÊï∞Èáè‰∏∫8
 149   1          DMA1_BA = DMAAddr & 0x07ff;                             // ËÆæÁΩÆDMA1ÂèëÈÄÅÈ¶ñÂú∞ÂùÄ
 150   1      
 151   1          Switch_DMA(1);                                       // ÂêØÂä®DMA1
 152   1      }
 153          
 154          
 155          void SetDbgData_DMA(unsigned short ulAddr)
 156          {
 157   1          bool bTmp = false;
 158   1      
 159   1          if (ReadBit(DMA1_CR0, DMAEN))
 160   1          {
 161   2              bTmp = true;
 162   2      
 163   2              while (ReadBit(DMA1_CR0, DMABSY));
 164   2              ClrBit(DMA1_CR0, DMAEN);
 165   2          }
 166   1      
 167   1          if (ulAddr <= 0xfff) ulAddr += 0x70000000;
 168   1          DMA1_BA = ulAddr;
 169   1      
 170   1          if (bTmp) SetBit(DMA1_CR0, DMAEN);
 171   1      }
 172          
 173          void EnableRun_DMA0(void)
 174          {
 175   1          SetBit(DMA0_CR0 , DMAEN | DMABSY);
 176   1      }
C51 COMPILER V9.53.0.0   DMA                                                               04/09/2024 13:54:56 PAGE 4   

 177          
 178          void EnableRun_DMA1(void)
 179          {
 180   1          SetBit(DMA1_CR0 , DMAEN | DMABSY);
 181   1      }
 182          
 183          bool GetStatus_DMA0(eType_DMA_Statu eStatu)
 184          {
 185   1          return ReadBit(DMA0_CR0 , eStatu);
 186   1      }
 187          
 188          bool GetStatus_DMA1(eType_DMA_Statu eStatu)
 189          {
 190   1          return ReadBit(DMA1_CR0 , eStatu);
 191   1      }
 192          


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    486    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
   EDATA SIZE       =   ----    ----
   HDATA SIZE       =   ----    ----
   XDATA CONST SIZE =   ----    ----
   FAR CONST SIZE   =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)

C51 COMPILER V9.53.0.0   MOTORCONTROLFUNCTION                                              04/09/2024 13:54:54 PAGE 1   


C51 COMPILER V9.53.0.0, COMPILATION OF MODULE MOTORCONTROLFUNCTION
OBJECT MODULE PLACED IN .\Objects\MotorControlFunction.obj
COMPILER INVOKED BY: D:\Keil_v5\C51\BIN\C51.EXE ..\User\source\Function\MotorControlFunction.c LARGE OMF2 OPTIMIZE(8,SPE
                    -ED) BROWSE INCDIR(..\FU68xx_Hardware_Driver\Include;..\User\include) DEBUG PRINT(.\Listings\MotorControlFunction.lst) TA
                    -BS(2) OBJECT(.\Objects\MotorControlFunction.obj)

line level    source

   1          /* --------------------------- (C) COPYRIGHT 2020 Fortiortech ShenZhen -----------------------------
   2              File Name      : MotorControlFunction.c
   3              Author         : Fortiortech  Appliction Team
   4              Version        : V1.0
   5              Date           : 2020-04-10
   6              Description    : This file contains .C file function used for Motor Control.
   7          ----------------------------------------------------------------------------------------------------  
   8                                                 All Rights Reserved
   9          ------------------------------------------------------------------------------------------------- */
  10          #include "FU68xx_4.h"
  11          #include "MyProject.h"
  12          
  13          CurrentOffset xdata mcCurOffset;
  14          AlignCalib_TypeDef  Align_Calib;
  15          
  16          #if (MOTOR_STARTDELAY_Enable == 1)
                uint16 Motor_DelayStart_CNT = 0;
              #endif
  19          
  20          
  21          
  22          /* -------------------------------------------------------------------------------------------------
  23              Function Name  : FOC_Init
  24              Description    : mcInitçŠ¶æ€ä¸‹ï¼Œå¯¹FOCçš„ç›¸å…³å¯„å­˜å™¨è¿›è¡Œé…ç½®,å…ˆæ¸…ç†å¯„å­˜å™¨ï¼Œåé…ç½®
             -ï¼Œæœ€åä½¿èƒ½
  25              Date           : 2020-04-10
  26              Parameter      : None
  27          ------------------------------------------------------------------------------------------------- */
  28          void FOC_Init(void)
  29          {
  30   1        ClrBit(DRV_CR , DRVEN);
  31   1        /*ä½¿èƒ½FOC*/
  32   1        ClrBit(DRV_CR , FOCEN);
  33   1        SetBit(DRV_CR , FOCEN);
  34   1      
  35   1        SetBit(FOC_CR0 , ESCMS);  
  36   1      
  37   1        ClrBit(FOC_CR0 , MERRS1); 
  38   1        ClrBit(FOC_CR0 , MERRS0); 
  39   1      
  40   1        FOC_EOMEKLPF    = 0xff;  
  41   1      
  42   1        FOC__EOME     = 0;
  43   1        FOC_EFREQACC  = 0;
  44   1        FOC_EFREQMIN  = 0;
  45   1        FOC_EFREQHOLD = 0;
  46   1        /*é…ç½®FOCå¯„å­˜å™¨*/
  47   1        FOC_CR1         = 0;                                    // æ¸…é›¶ FOC_CR1
  48   1        FOC_CR2         = 0;                                    // æ¸…é›¶ FOC_CR2
  49   1        FOC_IDREF       = 0;                                    // æ¸…é›¶ Id
  50   1        FOC_IQREF       = 0;                                    // æ¸…é›¶ Iq
  51   1      
  52   1        FOC__THETA      = 0;                                    // æ¸…é›¶ è§’åº¦
C51 COMPILER V9.53.0.0   MOTORCONTROLFUNCTION                                              04/09/2024 13:54:54 PAGE 2   

  53   1        FOC_RTHEACC     = 0;                                    // æ¸…é›¶ çˆ¬å¡å‡½æ•°çš„åˆå§‹åŠ é€Ÿåº¦
  54   1        FOC__RTHESTEP   = 0;                                    // æ¸…é›¶ çˆ¬å¡é€Ÿåº¦
  55   1        FOC__RTHECNT    = 0;                                    // æ¸…é›¶ çˆ¬å¡æ¬¡æ•°
  56   1        
  57   1        #if (SMO_OffSET_Enable == 1)
                {
                  FOC__THECOMP  = _Q15(SMO_OffSET_DEGREE / 180.0);     // SMO ä¼°ç®—è£œå„Ÿè§’
                }
                #elif (SMO_OffSET_Enable == 0)
  62   1        {
  63   2         FOC__THECOMP  = _Q15(0.0/180.0);         
  64   2        }
  65   1        #endif
  66   1        
  67   1        FOC__THECOR     = 0x04;                                 // è¯¯å·®è§’åº¦è¡¥å¿
  68   1      
  69   1        FOC_DMAX        =  DOUTMAX;
  70   1        FOC_DMIN        = -DOUTMAX;
  71   1        FOC_QMAX        =  QOUTMAX;
  72   1        FOC_QMIN        = -QOUTMAX;
  73   1      
  74   1        /*ä½ç½®ä¼°ç®—å‚æ•°é…ç½®*/
  75   1        FOC_EK1         = OBS_K1T;
  76   1        FOC_EK2         = OBS_K2T;
  77   1        FOC_EK3         = OBS_K3T;
  78   1        FOC_EK4         = OBS_K4T;
  79   1        FOC_FBASE       = OBS_FBASE;
  80   1        FOC_OMEKLPF     = SPEED_KLPF;
  81   1        FOC_EBMFK       = OBS_KLPF;
  82   1      
  83   1        FOC_TGLI        = 0x00;                                 // PWM_TGLI_LOAD;
  84   1      
  85   1        ClrBit(FOC_CR2, ESEL);                                  // ä½¿ç”¨ SMO ä¼°ç®—
  86   1        FOC_KSLIDE    = _Q15(OBS_KSLIDE);
  87   1        FOC_EKLPFMIN  = OBS_EA_KS;      
  88   1      
  89   1        SetBit(FOC_CR1 , SVPWMEN);                              // SVPWM æ¨¡å¼
  90   1      
  91   1        if(mcFRState.TargetFR == CW)
  92   1        {
  93   2            ClrBit(DRV_CR , DDIR);                              // åè½¬æ ‡å¿—ä½      
  94   2        }
  95   1        else
  96   1        {
  97   2            SetBit(DRV_CR , DDIR);                              // åè½‰è¨­å®š      
  98   2        }
  99   1        
 100   1        /**è¿‡è°ƒåˆ¶**/
 101   1        #if (OverModulation_Enable == 1)
 102   1        {
 103   2          SetBit(FOC_CR1 , OVMDL);                            // éèª¿é©
 104   2        }
 105   1        #endif //end OverModulation
 106   1      
 107   1      //    SetBit(FOC_CR0 , UCSEL);                              // å–æ¨£ ADC é€šé“è¨­å®š[é è¨­AD14]
 108   1        #if (HW_RV_MODE == RV6P5 || HW_RV_MODE == RV12)
                {
                  SetBit(FOC_CR0 , UCSEL);                
                }
                #elif (HW_RV_MODE == RVEXT)
 113   1        {
 114   2          ClrBit(FOC_CR0 , UCSEL);
C51 COMPILER V9.53.0.0   MOTORCONTROLFUNCTION                                              04/09/2024 13:54:54 PAGE 3   

 115   2        }
 116   1        #endif
 117   1      
 118   1      
 119   1        /*å•ç”µé˜»é‡‡æ ·ï¼›éœ€è¦æœ€å°é‡‡æ ·çª—,FOC_TRGDLYä¸º0ï¼Œä¸ƒæ®µå¼SVPWMæ–¹å¼*/
 120   1        #if (Shunt_Resistor_Mode == Single_Resistor)
 121   1        {
 122   2          SetReg(FOC_CR1 , CSM0 | CSM1 , 0x00);
 123   2          FOC_TSMIN  = PWM_TS_LOAD;                           // æœ€å°é‡‡æ ·çª—å£
 124   2          FOC_TRGDLY = 0x05;                                  // é‡‡æ ·æ—¶åˆ»åœ¨ä¸­ç‚¹ï¼Œä¸€èˆ¬è€ƒè™‘å¼€å…³å™ªå£
             -°å½±å“ï¼Œä¼šè®¾ç½®å»¶è¿Ÿï¼›
 125   2                                                              // 0x0cè¡¨ç¤ºå»¶è¿Ÿ12ä¸ªclockï¼Œæå‰ç”¨åç å½¢
             -å¼ï¼Œå¦‚0x84è¡¨ç¤ºæå‰12ä¸ªclockã€‚
 126   2          ClrBit(FOC_CR2 , F5SEG);                            // 7æ®µå¼
 127   2          SetReg(CMP_CR1 , CMP3MOD0 | CMP3MOD1, 0x00);
 128   2        }
 129   1        /*åŒç”µé˜»é‡‡æ ·ï¼Œå¯è®¾ç½®æ­»åŒºè¡¥å¿å€¼ï¼Œåœ¨ä¸‹é™æ²¿ç»“æŸå‰å¼€å§‹é‡‡æ ·Iaï¼Œé…ç½®81*/
 130   1        #elif (Shunt_Resistor_Mode == Double_Resistor)          // double resistor sample
                {
                  SetReg(FOC_CR1 , CSM0 | CSM1 , CSM0);
              
                  FOC_TSMIN = PWM_DT_LOAD;                            // æ­»åŒºè¡¥å¿å€¼
                  FOC_TRGDLY = 0x06;                                  // ADCé‡‡æ ·çš„æ—¶åˆ»ï¼Œé‡‡æ ·æ—¶åˆ»åœ¨è®¡æ•°å™¨é›
             -¶ç‚¹é™„è¿‘ï¼Œ83ä¸ºä¸‹é™æ²¿ç»“æŸå‰3ä¸ªclocké‡‡æ ·Iaï¼Œä¸å•ç”µé˜»ä¸åŒ
                                                                      // 01ä¸ºä¸Šå‡æ²¿å¼€å§‹åç¬¬ä¸€ä¸ªclockå¼€å§‹é‡‡æ
             - ·ã€‚æ ¹æ®å®é™…æƒ…å†µè°ƒæ•´ã€‚
                  FOC_TBLO = PWM_DLOWL_TIME;                          //ä¸‹æ¡¥è‡‚æœ€å°è„‰å†²ï¼Œä¿è¯é‡‡æ ·
                  SetReg(CMP_CR1 , CMP3MOD0 | CMP3MOD1 , 0x00);
              
                  /*äº”æ®µå¼æˆ–ä¸ƒæ®µå¼é€‰æ‹©*/
                  #if (SVPMW_Mode == SVPWM_7_Segment)
                  {
                      ClrBit(FOC_CR2 , F5SEG);                        // 7æ®µå¼
                  }
                  #elif (SVPMW_Mode == SVPWM_5_Segment)
                  {
                      SetBit(FOC_CR2 , F5SEG);                        // 5æ®µå¼
                  }
                  #endif
              
                  #if (DouRes_Sample_Mode == DouRes_1_Cycle)
                  {
                      ClrBit(FOC_CR2 , DSS);                          // 7æ®µå¼
                  }
                  #elif (DouRes_Sample_Mode == DouRes_2_Cycle)
                  {
                      SetBit(FOC_CR2 , DSS);                          // 5æ®µå¼
                  }
                  #endif //end DouRes_Sample_Mode
                }
                /*ä¸‰ç”µé˜»é‡‡æ ·*/
                #elif (Shunt_Resistor_Mode == Three_Resistor)           // signel resistor sample
                {
              
                  SetReg(FOC_CR1, CSM0 | CSM1 , CSM0 | CSM1);         // ä¸‰ç”µé˜»
              
                  FOC_TSMIN  = PWM_DT_LOAD;                           // æ­»åŒºè¡¥å¿å€¼
                  FOC_TRGDLY = 0x06;                                  // ADCé‡‡æ ·çš„æ—¶åˆ»ï¼Œé‡‡æ ·æ—¶åˆ»åœ¨è®¡æ•°å™¨é›
             -¶ç‚¹é™„è¿‘ï¼Œ83ä¸ºä¸‹é™æ²¿ç»“æŸå‰3ä¸ªclocké‡‡æ ·Iaï¼Œä¸å•ç”µé˜»ä¸åŒã€‚
                                                      // 01ä¸ºä¸Šå‡æ²¿å¼€å§‹åç¬¬ä¸€ä¸ªclockå¼€å§‹é‡‡æ ·ã€‚æ ¹æ®å®é™
             -…æƒ…å†µè°ƒæ•´ã€‚
              
C51 COMPILER V9.53.0.0   MOTORCONTROLFUNCTION                                              04/09/2024 13:54:54 PAGE 4   

                  SetReg(CMP_CR1, CMP3MOD0 | CMP3MOD1, CMP3MOD0 | CMP3MOD1);
                  FOC_TBLO= PWM_OVERMODULE_TIME;                      // è¿‡è°ƒåˆ¶ç”µæµé‡‡æ ·å¤„ç†çš„TBè„‰å®½
              
                  /*äº”æ®µå¼æˆ–ä¸ƒæ®µå¼é€‰æ‹©*/
                  #if (SVPMW_Mode == SVPWM_7_Segment)
                  {
                      ClrBit(FOC_CR2 , F5SEG);                        // 7æ®µå¼
                  }
                  #elif (SVPMW_Mode == SVPWM_5_Segment)
                  {
                      SetBit(FOC_CR2 , F5SEG);                        // 5æ®µå¼
                  }
                  #endif //end SVPMW_Mode
              
                  #if (DouRes_Sample_Mode == DouRes_1_Cycle)
                  {
                      ClrBit(FOC_CR2 , DSS);                          // 7æ®µå¼
                  }
                  #elif (DouRes_Sample_Mode == DouRes_2_Cycle)
                  {
                      SetBit(FOC_CR2 , DSS);                          // 5æ®µå¼
                  }
                  #endif //end DouRes_Sample_Mode
                }
                #endif  //end Shunt_Resistor_Mode
 196   1      
 197   1      
 198   1        /* ä½¿èƒ½ç”µæµåŸºå‡†æ ¡æ­£ */
 199   1        #if (currentCalib_Enable == 1)
 200   1        {
 201   2          if(mcCurOffset.OffsetFlag == 1)
 202   2          {
 203   3            #if (Shunt_Resistor_Mode == Single_Resistor)    // å•ç”µé˜»æ ¡æ­£
 204   3            {
 205   4              /*set ibus current sample offset*/
 206   4              SetReg(FOC_CR2 , CSOC0 | CSOC1 , 0x00);
 207   4              FOC_CSO = mcCurOffset.Iw_busOffset;         // å†™å…¥Ibusçš„åç½®
 208   4            }
 209   3            #elif (Shunt_Resistor_Mode == Double_Resistor)  // åŒç”µé˜»æ ¡æ­£
                    {
                      /*set ia, ib current sample offset*/
                      SetReg(FOC_CR2 , CSOC0 | CSOC1 , CSOC0);
                      FOC_CSO  = mcCurOffset.IuOffset;            // å†™å…¥IAçš„åç½®
              
                      SetReg(FOC_CR2 , CSOC0 | CSOC1 , CSOC1);
                      FOC_CSO  = mcCurOffset.IvOffset;            // å†™å…¥IBçš„åç½®
                    }
                    #elif (Shunt_Resistor_Mode == Three_Resistor)   // ä¸‰ç”µé˜»æ ¡æ­£
                    {
                      /*set ibus current sample offset*/
                      SetReg(FOC_CR2 , CSOC0 | CSOC1 , CSOC0);
                      FOC_CSO = mcCurOffset.IuOffset;             // å†™å…¥IAçš„åç½®
              
                      SetReg(FOC_CR2 , CSOC0 | CSOC1 , CSOC1);
                      FOC_CSO = mcCurOffset.IvOffset;             // å†™å…¥IBçš„åç½®
              
                      SetReg(FOC_CR2 , CSOC0 | CSOC1 , 0x00);
                      FOC_CSO = mcCurOffset.Iw_busOffset;         // å†™å…¥ICçš„åç½®
                    }
                    #endif  //end Shunt_Resistor_Mode
 231   3          }
 232   2        }
C51 COMPILER V9.53.0.0   MOTORCONTROLFUNCTION                                              04/09/2024 13:54:54 PAGE 5   

 233   1        #endif  //end CalibENDIS
 234   1        /*-------------------------------------------------------------------------------------------------
 235   1        DRV_CTLï¼šPWMæ¥æºé€‰æ‹©
 236   1        OCS = 0, DRV_COMR
 237   1        OCS = 1, FOC/SVPWM/SPWM
 238   1        -------------------------------------------------------------------------------------------------*/
 239   1        SetBit(DRV_CR , DRVEN);
 240   1        /*è®¡æ•°å™¨æ¯”è¾ƒå€¼æ¥æºFOC*/
 241   1        SetBit(DRV_CR , OCS);
 242   1      }
 243          
 244          /* -------------------------------------------------------------------------------------------------
 245              Function Name  : Motor_Charge
 246              Description    : é¢„å……ç”µï¼Œå½“ä¸€ç›´å¤„äºé¢„å……ç”µçŠ¶æ€ä¸‹ï¼Œä¸æ¥ç”µæœºï¼Œå¯ç”¨äºéªŒè¯IPMæˆ–è
             -€…Mosã€‚
 247                               é¢„å……ç”µåˆ†ä¸‰æ­¥ï¼Œç¬¬ä¸€æ­¥æ˜¯å¯¹Uç›¸è¿›è¡Œé¢„å……ç”µï¼Œç¬¬äºŒæ­¥æ˜¯å¯¹U,Vä¸¤ç›¸è¿›
             -è¡Œé¢„å……ç”µ;ç¬¬ä¸‰æ­¥æ˜¯å¯¹Uã€Vã€Wä¸‰ç›¸è¿›è¡Œé¢„å……ç”µã€‚
 248              Date           : 2020-04-10
 249              Parameter      : None
 250          ------------------------------------------------------------------------------------------------- */
 251          void Motor_Charge(void)
 252          {
 253   1        DRV_CMR |= 0x3F;                         // Uã€Vã€Wç›¸è¾“å‡º
 254   1      }
 255          
 256          /* -------------------------------------------------------------------------------------------------
 257              Function Name  : Motor_Align
 258              Description    : é¢„å®šä½å‡½æ•°ï¼Œå½“æ— é€†é£åˆ¤æ–­æ—¶ï¼Œé‡‡ç”¨é¢„å®šä½å›ºå®šåˆå§‹ä½ç½®;å½“æœ‰é€†
             -é£åˆ¤æ–­æ—¶ï¼Œé‡‡ç”¨é¢„å®šä½åˆ¹è½¦
 259              Date           : 2020-04-10
 260              Parameter      : None
 261          ------------------------------------------------------------------------------------------------- */
 262          int16 Align_Value = 0;
 263          void Motor_Align(void)
 264          {
 265   1        int16 tmpUD_Value = 0;
 266   1        if(McStaSet.SetFlag.AlignSetFlag == 0)
 267   1        {
 268   2          McStaSet.SetFlag.AlignSetFlag = 1;
 269   2          /* -----FOCåˆå§‹åŒ–----- */
 270   2          FOC_Init();
 271   2          MOE = 0;
 272   2          
 273   2          SetBit(FOC_CR2, UQD);               // é—œé–‰ UQ PI æ§åˆ¶å™¨
 274   2          SetBit(FOC_CR2, UDD);               // é—œé–‰ UD PI æ§åˆ¶å™¨
 275   2          
 276   2          Align_Calib.Align_IA = 0; 
 277   2          Align_Calib.Align_IB = 0;
 278   2          Align_Calib.Align_IC = 0;
 279   2          Align_Calib.Update_CNT = 0;
 280   2        
 281   2          //memset(&Align_Calib, 0, sizeof(Align_Calib));
 282   2          
 283   2          if(BEMFDetect.BEMFCCWFlag == 0)
 284   2          {
 285   3            FOC__UD = Align_Value;
 286   3            FOC__UQ = 0;
 287   3          }
 288   2          else
 289   2          {
 290   3            FOC__UD = Align_Value + _Q15(0.1);
 291   3            FOC__UQ = 0;
C51 COMPILER V9.53.0.0   MOTORCONTROLFUNCTION                                              04/09/2024 13:54:54 PAGE 6   

 292   3          }
 293   2      
 294   2          FOC_EKP     = OBSW_KP_GAIN;
 295   2          FOC_EKI     = OBSW_KI_GAIN;
 296   2          FOC__THETA  = Angle2RawTHETA(0.0);
 297   2      
 298   2          /*è¼¸å‡ºè‡´èƒ½*/
 299   2          DRV_CMR |= 0x3F; 
 300   2          MOE = 1;
 301   2        }
 302   1        else
 303   1        {
 304   2          if (Align_Calib.Counter == 0)
 305   2          {
 306   3            mcState = mcStart;
 307   3          }
 308   2          else if (Align_Calib.Counter <= (ALIGN_TIME - 150))
 309   2          {
 310   3            FOC__THETA = Angle2RawTHETA(ALIGN_ANGLE);
 311   3          }
 312   2          else
 313   2          {
 314   3            if (Align_Calib.Update_CNT == 0)
 315   3            {
 316   4              tmpUD_Value = (Align_Calib.Align_IA + Align_Calib.Align_IB + Align_Calib.Align_IC) >> 1;
 317   4              if ((tmpUD_Value) < (ALIGN_DQ_VALUE - I_Value(0.1)) && FOC__UD < ALIGN_DQ_MAXVALUE)
 318   4              {
 319   5                FOC__UQ  = 0;
 320   5                FOC__UD += _Q15(0.001);
 321   5              }
 322   4              else if ((tmpUD_Value) > (ALIGN_DQ_VALUE + I_Value(0.1)) && FOC__UD > 0)
 323   4              {
 324   5                FOC__UQ  = 0;
 325   5                FOC__UD -= _Q15(0.001);
 326   5              }
 327   4              SetReg(FOC_CR2, ICLR, ICLR);
 328   4              Align_Calib.Update_CNT  = 1;
 329   4            }
 330   3          }
 331   2        }
 332   1      }
 333          
 334          
 335          /* -------------------------------------------------------------------------------------------------
 336              Function Name  : Motor_Open
 337              Description    : å¼€ç¯å¯åŠ¨çš„å‚æ•°é…ç½®
 338              Date           : 2020-04-10
 339              Parameter      : None
 340          ------------------------------------------------------------------------------------------------- */
 341          void Motor_Open(void)
 342          {
 343   1        #if (Open_Start_Mode == Open_Start)
                {
                  static uint8 OpenRampCycles = 0;
                }
                #endif
 348   1      
 349   1        if (McStaSet.SetFlag.StartSetFlag == 0) 
 350   1        {
 351   2          McStaSet.SetFlag.StartSetFlag = 1;
 352   2        }
 353   1        FOC_Init();
C51 COMPILER V9.53.0.0   MOTORCONTROLFUNCTION                                              04/09/2024 13:54:54 PAGE 7   

 354   1      
 355   1        //FOC__THETA  = Align_Theta + _Q15(-20.0/180.0);             
 356   1        FOC__ETHETA = _Q15(-45.0/180.0);//4096;
 357   1        //FOC__ETHETA = FOC__THETA;
 358   1          
 359   1        //TimeCnt = FOC__ETHETA;
 360   1        
 361   1      //  if (BEMFDetect.BEMFCCWFlag == 1)    
 362   1      //  {   
 363   1      //    mcFocCtrl.mcIqref += I_Value(0.5);                    //é€†é£æ—¶ï¼ŒåŠ å¤§å¯åŠ¨ç”µæµ
 364   1      //  }
 365   1      //  else if (BEMFDetect.BEMFCCWFlag == 2) 
 366   1      //  {
 367   1      //    mcFocCtrl.mcIqref += I_Value(0.3);                    //é€†é£æ—¶ï¼ŒåŠ å¤§å¯åŠ¨ç”µæµ
 368   1      //  }
 369   1        FOC_DQKP = DQKP_START;
 370   1        FOC_DQKI = DQKI_START;
 371   1        
 372   1        /*å•Ÿå‹•æ¨¡å¼è¨­ç½®*/
 373   1        #if (Open_Start_Mode == Omega_Start)                      // Omega å•Ÿå‹•
                {
                  FOC_EKP  = OBSW_KP_GAIN;
                  FOC_EKI  = OBSW_KI_GAIN;
                  FOC_EFREQACC  = Motor_Omega_Ramp_ACC;
                  FOC_EFREQMIN  = Motor_Omega_Ramp_Min;
                  FOC_EFREQHOLD = Motor_Omega_Ramp_End;
                  SetReg(FOC_CR1, EFAE | RFAE | ANGM, EFAE | ANGM);
                  
                  mcFocCtrl.State_Count = 1500;
                  mcState   = mcRun;
                }
                #elif (Open_Start_Mode == Open_Start)                     // å¼·æ‹–å•Ÿå‹•
                {
                  FOC_RTHEACC   = Motor_Open_Ramp_ACC;     
                  FOC__RTHESTEP = Motor_Open_Ramp_Min;      
                  FOC__RTHECNT  = MOTOR_OPEN_ACC_CNT;    
                  SetReg(FOC_CR1, EFAE | RFAE | ANGM , RFAE);
                  if(OpenRampCycles < (MOTOR_OPEN_ACC_CYCLE - 1))
                  {
                    if(!ReadBit(FOC_CR1 , RFAE))
                    {
                      SetBit(FOC_CR1 , RFAE);
                      OpenRampCycles++;
                    }
                  }
                  else
                  {
                    mcFocCtrl.State_Count = 2;
                    mcState = mcRun;
                  }
                  FOC_EKP = OBSW_KP_GAIN_RUN4;                           
                  FOC_EKI = OBSW_KI_GAIN_RUN4;   
                }
                #elif (Open_Start_Mode == Open_Omega_Start)               // æ··åˆå•Ÿå‹•[å…ˆå¼·æ‹–å¾Œ Omega å•Ÿå‹•]
 408   1        {
 409   2          FOC_EKP  = OBSW_KP_GAIN;
 410   2          FOC_EKI  = OBSW_KI_GAIN;
 411   2          FOC_RTHEACC   = MOTOR_OPEN_ACC;      
 412   2          FOC__RTHESTEP = Motor_Open_Ramp_Min;    
 413   2          FOC__RTHECNT   = MOTOR_OPEN_ACC_CNT;          
 414   2          FOC_EFREQACC  = Motor_Omega_Ramp_ACC;
 415   2          FOC_EFREQMIN  = MOTOR_OMEGA_ACC_MIN;
C51 COMPILER V9.53.0.0   MOTORCONTROLFUNCTION                                              04/09/2024 13:54:54 PAGE 8   

 416   2          FOC_EFREQHOLD = MOTOR_OMEGA_ACC_END;
 417   2          SetReg(FOC_CR1, EFAE | RFAE | ANGM, EFAE | RFAE | ANGM);
 418   2          //SetReg(FOC_CR1, EFAE | RFAE | ANGM, EFAE | ANGM);
 419   2          mcFocCtrl.State_Count = 700;
 420   2          mcState = mcRun;
 421   2        }
 422   1        #endif 
 423   1          
 424   1        FOC_IDREF = ID_Start_CURRENT;                             // Dè½´å¯åŠ¨ç”µæµ
 425   1        
 426   1        if (BEMFDetect.BEMFCCWFlag != 0)    
 427   1        {   
 428   2           mcFocCtrl.mcIqref = IQ_Tailwind_Start_CURRENT;                    //é€†é£æ—¶ï¼ŒåŠ å¤§å¯åŠ¨ç”µæµ
 429   2        }
 430   1        else
 431   1        {
 432   2           mcFocCtrl.mcIqref = IQ_Start_CURRENT;                    // Qè½´å¯åŠ¨ç”µæµ
 433   2        }
 434   1        
 435   1        //mcFocCtrl.mcIqref = IQ_Start_CURRENT;                     // Qè½´å¯åŠ¨ç”µæµ
 436   1        FOC_IQREF = mcFocCtrl.mcIqref;                            // Qè»¸å•Ÿå‹•é›»æµ
 437   1        
 438   1        ClrBit(FOC_CR2, UQD);
 439   1        ClrBit(FOC_CR2, UDD);
 440   1      
 441   1      }
 442          
 443          /* -------------------------------------------------------------------------------------------------
 444              Function Name  : Motor_TailWind
 445              Description    : é¡ºé£é€†é£å‚æ•°é…ç½®å‡½æ•°
 446              Date           : 2020-04-10
 447              Parameter      : None
 448          ------------------------------------------------------------------------------------------------- */
 449          void Motor_TailWind(void)
 450          {
 451   1          if(mcFocCtrl.State_Count == 0)
 452   1          {
 453   2            if(BEMFDetect.BEMFBrakeFlag == 0)
 454   2            {
 455   3              if(McStaSet.SetFlag.TailWindSetFlag == 0)
 456   3              {
 457   4                  McStaSet.SetFlag.TailWindSetFlag = 1;
 458   4                  BEMFDetectInit();
 459   4              }
 460   3              BEMFDealwith();
 461   3            }
 462   2            else
 463   2            {
 464   3                mcState             = mcAlign;
 465   3                Align_Calib.Counter = TailWindAlign_Time;
 466   3            }
 467   2          }
 468   1      }
 469          
 470          /* -------------------------------------------------------------------------------------------------
 471              Function Name  : MC_Stop
 472              Description    : inital motor control parameter
 473              Date           : 2020-04-10
 474              Parameter      : None
 475          ------------------------------------------------------------------------------------------------- */
 476          void MC_Stop(void)
 477          {
C51 COMPILER V9.53.0.0   MOTORCONTROLFUNCTION                                              04/09/2024 13:54:54 PAGE 9   

 478   1          MOE     = 0;
 479   1          ClrBit(DRV_CR , FOCEN);   //å…³é—­FOC                                                                 
             -                                        // disable FOC output and initial register
 480   1          mcState = mcInit;
 481   1      }
 482          
 483          /* -------------------------------------------------------------------------------------------------
 484              Function Name  : MotorcontrolInit
 485              Description    : æ§åˆ¶å˜é‡åˆå§‹åŒ–æ¸…é›¶,åŒ…æ‹¬ä¿æŠ¤å‚æ•°çš„åˆå§‹åŒ–ã€ç”µæœºçŠ¶æ€åˆå§‹åŒ–
 486              Date           : 2020-04-10
 487              Parameter      : None
 488          ------------------------------------------------------------------------------------------------- */
 489          void MotorcontrolInit(void)
 490          {
 491   1          /* -----ä¿æŠ¤å‚æ•°åˆå§‹åŒ–----- */
 492   1          faultVarible_Initial();
 493   1          
 494   1          /* -----è¿‡æµä¿æŠ¤----- */
 495   1          memset(&mcCurVarible , 0 , sizeof(CurrentVarible));   // ç”µæµä¿æŠ¤çš„å˜é‡æ¸…é›¶
 496   1          /* -----é¡ºé€†é£åˆ¤æ–­å‚æ•°åˆå§‹åŒ–----- */
 497   1          memset(&BEMFDetect , 0 , sizeof(BEMFDetect_TypeDef));//  BEMFDetectæ‰€æœ‰å˜é‡æ¸…é›¶
 498   1      
 499   1          /*****ç”µæœºçŠ¶æ€æœºæ—¶åºå˜é‡***********/
 500   1          McStaSet.SetMode                   = 0;
 501   1          
 502   1          /**********ç”µæœºç›®æ ‡æ–¹å‘*************/
 503   1          #if (MOTOR_DIRECTION == 0)
 504   1          {
 505   2            mcFRState.TargetFR = CW;
 506   2          }
 507   1          #else
                  {
                    mcFRState.TargetFR = CCW;
                  }
                  #endif //end IRMODE
 512   1      
 513   1          /* -----å¤–éƒ¨æ§åˆ¶ç¯----- */
 514   1          memset(&mcFocCtrl , 0 , sizeof(FOCCTRL));           // mcFocCtrlå˜é‡æ¸…é›¶
 515   1          /* -----ADCé‡‡æ ·æ»¤æ³¢å€¼----- */
 516   1          memset(&ADCSampling, 0, sizeof(ADCSample_TypeDef));    // ADCSampleå˜é‡æ¸…é›¶
 517   1          /* -----ç”µæµåç½®æ ¡å‡†å˜é‡åˆå§‹åŒ–----- */
 518   1          memset(&mcCurOffset , 0 , sizeof(CurrentOffset));  // mcCurOffsetå˜é‡æ¸…é›¶
 519   1          mcCurOffset.IuOffsetSum            = 16383;
 520   1          mcCurOffset.IvOffsetSum            = 16383;
 521   1          mcCurOffset.Iw_busOffsetSum        = 16383;
 522   1          /* -----é€Ÿåº¦ç¯å“åº”å‚æ•°åˆå§‹åŒ–----- */
 523   1          memset(&mcSpeedRamp , 0 , sizeof(MCRAMP));        // mcSpeedRampå˜é‡æ¸…é›¶
 524   1          /* -----PWMè°ƒé€Ÿå˜é‡åˆå§‹åŒ–----- */
 525   1          memset(&mcPwmInput , 0 , sizeof(PWMINPUTCAL));    // mcPwmInputå˜é‡æ¸…é›¶
 526   1      //    mcPwmInput.PWMARR = 32767;
 527   1          
 528   1          mcSpeedRamp.FlagONOFF = 1;
 529   1      }
 530          
 531          
 532          /* -------------------------------------------------------------------------------------------------
 533              Function Name  : VariablesPreInit
 534              Description    : åˆå§‹åŒ–ç”µæœºå‚æ•°
 535              Date           : 2020-04-10
 536              Parameter      : None
 537          ------------------------------------------------------------------------------------------------- */
 538          void VariablesPreInit(void)
C51 COMPILER V9.53.0.0   MOTORCONTROLFUNCTION                                              04/09/2024 13:54:54 PAGE 10  

 539          {
 540   1        mcFaultSource.Source = NoFault;
 541   1        /* -----é¡ºé€†é£å‚æ•°åˆå§‹åŒ–----- */
 542   1        tailWindVarible_Initial();
 543   1        /* -----ä¿æŠ¤å‚æ•°åˆå§‹åŒ–----- */
 544   1        faultVarible_Initial();
 545   1        /* -----å¤–éƒ¨æ§åˆ¶ç¯å‚æ•°åˆå§‹åŒ–----- */
 546   1        memset(&mcFocCtrl , 0 , sizeof(FOCCTRL));            // mcFocCtrlå˜é‡æ¸…é›¶
 547   1        memset(&mcVspInput,0, sizeof(VSPINPUTCAL));
 548   1        /*****ç”µæœºçŠ¶æ€æœºæ—¶åºå˜é‡***********/
 549   1        McStaSet.SetMode                  = 0x01;           //ç”µæµæ ¡å‡†æ ‡å¿—ä½ç½®1ï¼Œå…¶å®ƒç½®0
 550   1      }
 551          
 552          /* -------------------------------------------------------------------------------------------------
 553              Function Name  : GetCurrentOffset
 554              Description    : ä¸Šç”µæ—¶ï¼Œå…ˆå¯¹ç¡¬ä»¶ç”µè·¯çš„ç”µæµè¿›è¡Œé‡‡é›†ï¼Œå†™å…¥å¯¹åº”çš„æ ¡å‡†å¯„å­˜å™¨ä
             -¸­ã€‚
 555                               è°ƒè¯•æ—¶ï¼Œéœ€è§‚å¯ŸmcCurOffsetç»“æ„ä½“ä¸­å¯¹åº”å˜é‡æ˜¯å¦åœ¨èŒƒå›´å†…ã€‚é‡‡é›†ç»
             -“æŸåï¼ŒOffsetFlagç½®1ã€‚
 556              Date           : 2020-04-10
 557              Parameter      : None
 558          ------------------------------------------------------------------------------------------------- */
 559          void GetCurrentOffset(void)
 560          {
 561   1        if(!mcCurOffset.OffsetFlag)
 562   1        {
 563   2        SetBit(ADC_CR , ADCBSY);            // ä½¿èƒ½ADC
 564   2          while(ReadBit(ADC_CR , ADCBSY));
 565   2      
 566   2          #if (Shunt_Resistor_Mode == Single_Resistor)                   //å•ç”µé˜»æ¨¡å¼
 567   2          {
 568   3          mcCurOffset.Iw_busOffsetSum += ((ADC4_DR& 0x7ff8));
 569   3            mcCurOffset.Iw_busOffset     = mcCurOffset.Iw_busOffsetSum >> 4;
 570   3            mcCurOffset.Iw_busOffsetSum -= mcCurOffset.Iw_busOffset;
 571   3          }
 572   2          #elif (Shunt_Resistor_Mode == Double_Resistor)                 //åŒç”µé˜»æ¨¡å¼
                  {
                  mcCurOffset.IuOffsetSum     += ((ADC0_DR& 0x7ff8));
                    mcCurOffset.IuOffset         = mcCurOffset.IuOffsetSum >> 4;
                    mcCurOffset.IuOffsetSum     -= mcCurOffset.IuOffset;
              
                    mcCurOffset.IvOffsetSum     += ((ADC1_DR& 0x7ff8));
                    mcCurOffset.IvOffset         = mcCurOffset.IvOffsetSum >> 4;
                    mcCurOffset.IvOffsetSum     -= mcCurOffset.IvOffset;
                  }
                #elif (Shunt_Resistor_Mode == Three_Resistor)                 //ä¸‰ç”µé˜»æ¨¡å¼
                  {
                  mcCurOffset.IuOffsetSum     += ((ADC0_DR& 0x7ff8));
                    mcCurOffset.IuOffset         = mcCurOffset.IuOffsetSum >> 4;
                    mcCurOffset.IuOffsetSum     -= mcCurOffset.IuOffset;
                    
                  mcCurOffset.IvOffsetSum     += ((ADC1_DR& 0x7ff8));
                  mcCurOffset.IvOffset         = mcCurOffset.IvOffsetSum >> 4;
                  mcCurOffset.IvOffsetSum     -= mcCurOffset.IvOffset;
                    
                  mcCurOffset.Iw_busOffsetSum += ((ADC4_DR& 0x7ff8));
                  mcCurOffset.Iw_busOffset     = mcCurOffset.Iw_busOffsetSum >> 4;
                  mcCurOffset.Iw_busOffsetSum -= mcCurOffset.Iw_busOffset;
                }
                  #endif
 597   2      
 598   2          mcCurOffset.OffsetCount++;
C51 COMPILER V9.53.0.0   MOTORCONTROLFUNCTION                                              04/09/2024 13:54:54 PAGE 11  

 599   2          
 600   2          if(mcCurOffset.OffsetCount > Calib_Time)
 601   2        {     
 602   3          mcCurOffset.OffsetFlag = 1;   
 603   3        }
 604   2        }
 605   1      }
 606          
 607          
 608          /* -------------------------------------------------------------------------------------------------
 609              Function Name  : Motor_Ready
 610              Description    : ä¸Šç”µæ—¶ï¼Œå…³é—­è¾“å‡ºï¼Œå…ˆå¯¹ç¡¬ä»¶ç”µè·¯çš„ç”µæµè¿›è¡Œé‡‡é›†ï¼Œåœ¨FOC_Initä¸­å†
             -™å…¥å¯¹åº”çš„æ ¡å‡†å¯„å­˜å™¨ä¸­ã€‚
 611                               è°ƒè¯•æ—¶ï¼Œéœ€è§‚å¯ŸmcCurOffsetç»“æ„ä½“ä¸­å¯¹åº”å˜é‡æ˜¯å¦åœ¨èŒƒå›´å†…ã€‚
 612              Date           : 2020-04-10
 613              Parameter      : None
 614          ------------------------------------------------------------------------------------------------- */
 615          void Motor_Ready(void)
 616          {
 617   1        if(McStaSet.SetFlag.CalibFlag == 0)
 618   1        {
 619   2        McStaSet.SetFlag.CalibFlag = 1;
 620   2          ClrBit(DRV_CR , FOCEN);
 621   2          ClrBit(DRV_CR , DRVEN);
 622   2          MOE = 0;
 623   2          SetBit(ADC_MASK, CH4EN | CH2EN | CH1EN | CH0EN);
 624   2          mcCurOffset.OffsetFlag  = 0;  
 625   2        /*20200704 æ›´æ–°*/
 626   2        mcCurOffset.OffsetCount     = 0;
 627   2        /**************/
 628   2        BEMFDetect.BEMFBrakeFlag       = 0;
 629   2        BEMFDetect.BEMFBrakeStepFlag = 0;
 630   2        BEMFDetect.BEMFStartDelayStatus = 0;
 631   2        BEMFDetect.BEMF_Function_Count = 0;
 632   2        BEMFDetect.BEMF_Function_Flag = 0;
 633   2        BEMFDetect.BEMF_Function_Time_Out_Count = 0;
 634   2        BEMFDetect.BEMF_Function_Time_Out_Flag = 0;
 635   2        }
 636   1      }
 637          
 638          
 639          /* -------------------------------------------------------------------------------------------------
 640              Function Name  : Motor_Init
 641              Description    : å¯¹ç”µæœºç›¸å…³å˜é‡ã€PIè¿›è¡Œåˆå§‹åŒ–è®¾ç½®
 642              Date           : 2020-04-10
 643              Parameter      : None
 644          ------------------------------------------------------------------------------------------------- */
 645          void Motor_Init(void)
 646          {
 647   1      //  ClrBit(ADC_MASK , CH4EN | CH1EN | CH0EN);   // å…³é—­è½¯ä»¶ç”µæµé‡‡æ ·çš„ADC
 648   1        ClrBit(ADC_MASK , CH4EN | CH0EN);   // å…³é—­è½¯ä»¶ç”µæµé‡‡æ ·çš„ADC
 649   1        VariablesPreInit();                           // ç”µæœºç›¸å…³å˜é‡åˆå§‹åŒ–
 650   1        PI_Init();                                    // PIåˆå§‹åŒ–   
 651   1        SetBit(DRV_CR , DRVEN);
 652   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   1460    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =     32    ----
   PDATA SIZE       =   ----    ----
C51 COMPILER V9.53.0.0   MOTORCONTROLFUNCTION                                              04/09/2024 13:54:54 PAGE 12  

   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
   EDATA SIZE       =   ----    ----
   HDATA SIZE       =   ----    ----
   XDATA CONST SIZE =   ----    ----
   FAR CONST SIZE   =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)

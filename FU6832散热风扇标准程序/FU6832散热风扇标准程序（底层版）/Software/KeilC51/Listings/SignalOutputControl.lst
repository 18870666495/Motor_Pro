C51 COMPILER V9.53.0.0   SIGNALOUTPUTCONTROL                                               04/09/2024 13:54:55 PAGE 1   


C51 COMPILER V9.53.0.0, COMPILATION OF MODULE SIGNALOUTPUTCONTROL
OBJECT MODULE PLACED IN .\Objects\SignalOutputControl.obj
COMPILER INVOKED BY: D:\Keil_v5\C51\BIN\C51.EXE ..\User\source\Function\SignalOutputControl.c LARGE OMF2 OPTIMIZE(8,SPEE
                    -D) BROWSE INCDIR(..\FU68xx_Hardware_Driver\Include;..\User\include) DEBUG PRINT(.\Listings\SignalOutputControl.lst) TABS
                    -(2) OBJECT(.\Objects\SignalOutputControl.obj)

line level    source

   1          /**
   2            ******************************************************************************
   3            * @file           : SignalOutputControl.c
   4            * @copyright      : (c) 2023, Fortior Tech
   5            * @brief          : 信號輸出相關程序
   6            ******************************************************************************
   7            * @attention
   8            *
   9            * This software is licensed under terms that can be found in the LICENSE file
  10            * in the root directory of this software component.
  11            * If no LICENSE file comes with this software, it is provided AS-IS.
  12            *
  13            ******************************************************************************
  14            */
  15          
  16          
  17          /* 標頭檔        Includes ----------------------------------------------------*/
  18          #include <FU68xx_4.h>
  19          #include "MyProject.h"
  20          
  21          /* 私有型別      Private typedef ---------------------------------------------*/
  22          #include "SignalOutputControl.h"
  23          
  24          /* 私有定義      Private define ----------------------------------------------*/
  25          #ifndef RDSignal_DelayTIM
  26           #define RDSignal_DelayTIM                    (1000)                                  /*!< RD 信號遲滯
             -時間 */
  27          #endif
  28          
  29          /* 私有巨集      Private macro -----------------------------------------------*/
  30          #define speedFlt2FG(_Val_)                    (uint16)(FG_TIMCLOCK / ((float)SpeedFlt2RPM(_Val_) / 30.0))
  31            
  32          /* 私有變數      Private variables -------------------------------------------*/
  33          /* 私有函式宣告  Private function prototypes ---------------------------------*/
  34          /* 私有函式      Private functions -------------------------------------------*/
  35          
  36          
  37          #if (ROTATESIGNAL_TYPE == FG_TYPE)
  38          typedef struct {
  39            uint8  isPause;
  40            uint8  Update;
  41            int16  delayTime;
  42            uint16 FG_ARR_Val;
  43            uint16 Fake_SPD;
  44            
  45          }signalOutput_HandleType;
  46          
  47          #elif (ROTATESIGNAL_TYPE == RD_TYPE)
              typedef struct{
                uint8  prev_State;
                uint8  RD_Level;
                uint8  state;
                uint8  isPause;
C51 COMPILER V9.53.0.0   SIGNALOUTPUTCONTROL                                               04/09/2024 13:54:55 PAGE 2   

                int16  delayTime;
                int16  wait_CNT;
              }signalOutput_HandleType;
              
              #endif
  58          
  59          
  60          signalOutput_HandleType SO_Var;
  61          
  62          void SignalOutput_initial(void) 
  63          {
  64   1        #if (ROTATESIGNAL_TYPE == FG_TYPE)
  65   1        {
  66   2          SO_Var.isPause   = 0;
  67   2          SO_Var.Update    = 0;
  68   2          SO_Var.delayTime = 800;
  69   2        }
  70   1        #elif (ROTATESIGNAL_TYPE == RD_TYPE)
                {
                  SO_Var.state     = 1;
                  SO_Var.RD_Level  = SO_Var.state;
                  SO_Var.delayTime = 10000;
                }
                #endif
  77   1      }
  78          
  79          
  80          uint8 SignalOutput_Process(void)
  81          {
  82   1        
  83   1        #if (ROTATESIGNAL_TYPE == FG_TYPE)
  84   1        {
  85   2          if (mcFocCtrl.CtrlMode == 1 && SO_Var.delayTime == 0 && SO_Var.isPause == 0)
  86   2          {
  87   3            if (SO_Var.Fake_SPD != 0)
  88   3            {
  89   4              SO_Var.FG_ARR_Val = speedFlt2FG(SO_Var.Fake_SPD);
  90   4              SO_Var.Fake_SPD   = 0;
  91   4              SO_Var.delayTime  = 1000;
  92   4            }
  93   3            else
  94   3            {
  95   4              SO_Var.FG_ARR_Val = speedFlt2FG(mcFocCtrl.SpeedFlt);
  96   4              SO_Var.delayTime  = 200;
  97   4            }
  98   3            
  99   3            SO_Var.Update = 1;
 100   3            if (!ReadBit(PH_SEL, T4SEL))
 101   3            {
 102   4              TIM4__ARR = SO_Var.FG_ARR_Val;
 103   4              TIM4__DR  = (TIM4__ARR >> 1);
 104   4              SetBit(PH_SEL, T4SEL);
 105   4            }
 106   3          }
 107   2          
 108   2          if ((mcFaultSource.Source != NoFault || mcSpeedRamp.FlagONOFF == 0) && SO_Var.isPause == 0)
 109   2          {
 110   3            
 111   3            if (ReadBit(PH_SEL, T4SEL))
 112   3            {
 113   4              ClrBit(PH_SEL, T4SEL);
 114   4              GP00 = 1;
C51 COMPILER V9.53.0.0   SIGNALOUTPUTCONTROL                                               04/09/2024 13:54:55 PAGE 3   

 115   4            }
 116   3            SO_Var.Fake_SPD  = 0;
 117   3            SO_Var.delayTime = 800;
 118   3          }
 119   2          return 0x00;
 120   2        }
 121   1        #elif (ROTATESIGNAL_TYPE == RD_TYPE)
                { 
                  if (SO_Var.state == 1 && ((mcFocCtrl.SpeedFlt < RPM2SpeedFlt((MOTOR_MINSPEED * 0.5)) && mcSpeedRamp.Fl
             -agONOFF == 1 && mcFocCtrl.CtrlMode == 1) || mcFaultSource.Source != NoFault))
                  {
                    SO_Var.wait_CNT  = -1;
                    SO_Var.delayTime = RDSignal_DelayTIM;
                    SO_Var.state = 0;
                  }
                  else if (SO_Var.state == 0 && (mcFocCtrl.SpeedFlt > RPM2SpeedFlt((MOTOR_MINSPEED * 0.7)) && mcSpeedRam
             -p.FlagONOFF == 1 && mcFocCtrl.CtrlMode == 1))
                  {
                    if (SO_Var.wait_CNT == -1)
                      SO_Var.wait_CNT = 200;
                    else if (SO_Var.wait_CNT == 0)
                    {
                      SO_Var.delayTime = RDSignal_DelayTIM;
                      SO_Var.state = 1;
                    }
                  }
                  
                  if (SO_Var.delayTime == 0)
                    SO_Var.RD_Level = SO_Var.state;
                  
                  if (SO_Var.isPause == 0)
                    return SO_Var.RD_Level;
                  else
                    return 1;      
                }
                #endif
 149   1      }
 150          
 151          
 152          void SignalOutput_Counter(void)
 153          {
 154   1        #if (ROTATESIGNAL_TYPE == FG_TYPE)
 155   1        {
 156   2          if (SO_Var.delayTime > 0 && mcFocCtrl.CtrlMode == 1) 
 157   2            SO_Var.delayTime--;
 158   2        }
 159   1        #elif (ROTATESIGNAL_TYPE == RD_TYPE)
                {
                  if (SO_Var.delayTime > 0) 
                    SO_Var.delayTime--;
                  if (SO_Var.wait_CNT > 0)
                    SO_Var.wait_CNT--;
                }
                #endif
 167   1      }
 168          
 169          
 170          
 171          
 172          
 173          #if (ROTATESIGNAL_TYPE == FG_TYPE)
 174          
C51 COMPILER V9.53.0.0   SIGNALOUTPUTCONTROL                                               04/09/2024 13:54:55 PAGE 4   

 175          void FG_setFakeSpped(uint16 value)
 176          {
 177   1        SO_Var.Fake_SPD = value;
 178   1      }
 179          
 180          
 181          void FG_Update_Event(void)
 182          {
 183   1        if (SO_Var.Update == 1 && SO_Var.isPause == 0)
 184   1        {
 185   2          TIM4__ARR = SO_Var.FG_ARR_Val;
 186   2          TIM4__DR = (TIM4__ARR >> 1);
 187   2          SO_Var.Update = 0;
 188   2        }
 189   1      } 
 190          
 191          #endif
 192          
 193          
 194          void SignalOutput_Pause(void)
 195          {
 196   1        #if (ROTATESIGNAL_TYPE == FG_TYPE)
 197   1        {
 198   2          ClrBit(PH_SEL, T4SEL);
 199   2          GP00 = 1;
 200   2          SO_Var.isPause = 1;
 201   2        }
 202   1        #elif (ROTATESIGNAL_TYPE == RD_TYPE)
                {
                  SO_Var.isPause = 1;
                }
                #endif
 207   1      }
 208          
 209          
 210          /**
 211            * @brief   FG/RD 輸出接續函數
 212            * @retval  無
 213            */
 214          void SignalOutput_Continue(void)
 215          {
 216   1        #if (ROTATESIGNAL_TYPE == FG_TYPE)
 217   1        {
 218   2          ClrBit(PH_SEL, T4SEL);
 219   2          SO_Var.Update = 0;
 220   2        }
 221   1        #endif
 222   1        SO_Var.isPause  = 0;
 223   1      }
 224          
 225          


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    483    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =      8    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
   EDATA SIZE       =   ----    ----
C51 COMPILER V9.53.0.0   SIGNALOUTPUTCONTROL                                               04/09/2024 13:54:55 PAGE 5   

   HDATA SIZE       =   ----    ----
   XDATA CONST SIZE =   ----    ----
   FAR CONST SIZE   =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)

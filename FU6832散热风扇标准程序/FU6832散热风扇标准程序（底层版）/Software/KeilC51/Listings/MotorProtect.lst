C51 COMPILER V9.53.0.0   MOTORPROTECT                                                      04/09/2024 13:54:55 PAGE 1   


C51 COMPILER V9.53.0.0, COMPILATION OF MODULE MOTORPROTECT
OBJECT MODULE PLACED IN .\Objects\MotorProtect.obj
COMPILER INVOKED BY: D:\Keil_v5\C51\BIN\C51.EXE ..\User\source\Function\MotorProtect.c LARGE OMF2 OPTIMIZE(8,SPEED) BROW
                    -SE INCDIR(..\FU68xx_Hardware_Driver\Include;..\User\include) DEBUG PRINT(.\Listings\MotorProtect.lst) TABS(2) OBJECT(.\O
                    -bjects\MotorProtect.obj)

line level    source

   1          /**
   2            ******************************************************************************
   3            * @file           : MotorProtect.c
   4            * @copyright      : (c) 2022, Fortior Tech
   5            * @brief          : 
   6            * @date           : 2023-01-31
   7            * @version        : 1.0.1
   8            *
   9            ******************************************************************************
  10            * @attention
  11            *
  12            * This software is licensed under terms that can be found in the LICENSE file
  13            * in the root directory of this software component.
  14            * If no LICENSE file comes with this software, it is provided AS-IS.
  15            *
  16            ******************************************************************************
  17            */  
  18          /* Includes ------------------------------------------------------------------*/
  19          #include <FU68xx_4.h>
  20          
  21          /* Private includes ----------------------------------------------------------*/
  22          #include "MyProject.h"
  23          
  24          /* Private typedef -----------------------------------------------------------*/
  25          typedef struct
  26          {
  27            uint16 segment;                                                             /*!< ‰øùË≠∑ÂÅµÊ∏¨Ëº™Ë©¢Ë®àÊï
             -∏Âô® */
  28            
  29            uint16 VoltDetecCnt;                                                        /*!< ÈÅéÊ¨†ÈõªÂ£ìÊ™¢Ê∏¨Ë®àÊï
             -∏Âô® */
  30            uint16 VoltRecoverCnt;                                                      /*!< ÈÅéÊ¨†ÈõªÂ£ìÊÅ¢Âæ©Ë®àÊï
             -∏Âô® */
  31            uint16 CurrentRecoverCnt;                                                   /*!< ÈÅéÈõªÊµÅÊÅ¢Âæ©Ë®àÊï∏Âô
             -® */
  32          
  33            uint16 StallDelayCnt;                                                       /*!< Â†µËΩâÂª∂ÈÅ≤Ë®àÊï∏Âô® *
             -/
  34            uint16 StallDectSpeed;                                                      /*!< Â†µËΩâÂ§±ÈÄüË®àÊï∏Âô® *
             -/
  35            uint16 StallSpeedAndEsCnt;                                                  /*!< Â†µËΩâËΩâÈÄüËàáÂèçÈõªÂã
             -ïÂã¢Â§±Ë°°Ë®àÊï∏Âô® */
  36            uint16 FOCUQ_Stall_Count;                                                   /*!< Â†µËΩâ FOC_UQÊ∫¢‰ΩçË®àÊ
             -ï∏Âô® */
  37            uint16 StartFocmode;                                                        /*!< Â†µËΩâ Èï∑ÊôÇÈñìÂú®mode
             -0Ë®àÊï∏Âô® */
  38            uint16 StallReCount;                                                        /*!< Â†µËΩâ‰øùË≠∑ÊÅ¢Âæ©Ë®àÊï
             -∏Âô® */
  39          
  40            uint16 Lphasecnt;                                                           /*!< Ê¨†Áõ∏‰øùË≠∑Ë®àÊï∏Âô® *
             -/
  41            uint16 AOpencnt ;                                                           /*!< AÁõ∏Ê¨†Áõ∏Ë®àÊï∏Âô® */
  42            uint16 BOpencnt ;                                                           /*!< BÁõ∏Ê¨†Áõ∏Ë®àÊï∏Âô® */ 
C51 COMPILER V9.53.0.0   MOTORPROTECT                                                      04/09/2024 13:54:55 PAGE 2   

  43            uint16 COpencnt ;                                                           /*!< CÁõ∏Ê¨†Áõ∏Ë®àÊï∏Âô® */
  44            uint16 mcLossPHRecCount;                                                    /*!< Ê¨†Áõ∏ÊÅ¢Âæ©Ë®àÊï∏Âô® *
             -/
  45          
  46          }FaultVarible;
  47          
  48          
  49          /* Private define ------------------------------------------------------------*/
  50          #define Stall_ATOEndTime                      (uint16)((1400) + 10)           /*!< Â†µËΩâÊ™¢Ê∏¨Áî® ATO ÈÄæ
             -ÊôÇÊôÇÈñì */
  51          
  52          /* Private macro -------------------------------------------------------------*/
  53          /* Private variables ---------------------------------------------------------*/
  54          //FaultStateType       mcFaultSource;
  55          motorFault_FlagDef xdata mcFaultSource;
  56          FaultVarible       idata mcFaultDect;
  57          ProtectVarible     idata mcProtectTime;
  58          
  59          uint16 Stall_Diff_RecoverTime = 0;
  60          uint16 Stall_CCW_State_Count  = 0;
  61          
  62          #if (Stall_retryStart_Enable == 1)
               uint8 Stall_retryCounter   = 0;
               uint8 STall_retryIdle_Flag = 0;
              #endif
  66          
  67          /* Private function prototypes -----------------------------------------------*/
  68          void Fault_phaseLoss(void);
  69          void Fault_OverUnderVoltage(void);
  70          void Fault_Detection(void);
  71          void Fault_Stall(void);
  72          void FaultProcess(void);
  73          void Fault_softOverCurrent(CurrentVarible *);
  74          void Fault_OverCurrentRecover(void);
  75          
  76          /* Private user code ---------------------------------------------------------*/
  77          /**
  78            * @brief         ‰øùË≠∑ÂäüËÉΩÁõ∏ÈóúËÆäÊï∏ÂàùÂßãÂåñ
  79            * @detail        ‰øùË≠∑Áõ∏ÈóúËÆäÊï∏ÂàùÂßãÂåñ @note Êú¨ÂáΩÊï∏Ë™øÁî®ÊôÇÂãôÂøÖÁ¢∫Ë™çÁõ∏ÈóúËÆäÊï∏Â∑≤ÂÆåÊàêÂ†
             -ÜÁñäÊàñ‰∏çÂÜç‰ΩøÁî®„ÄÇ
  80            * @retval        ÁÑ°
  81            */
  82          void faultVarible_Initial(void)
  83          {
  84   1        // ÂáΩÊï∏Âü∑Ë°åÈñãÂßã
  85   1        memset(&mcFaultDect,   0, sizeof(FaultVarible));
  86   1        memset(&mcProtectTime, 0, sizeof(ProtectVarible)); 
  87   1        // ÂáΩÊï∏Âü∑Ë°åÁµêÊùü
  88   1      }
  89          
  90          
  91          /**
  92            * @brief         Áï∞Â∏∏Ê™¢Ê∏¨Ëº™Ë©¢ÂáΩÊï∏
  93            * @detail        Áï∞Â∏∏Ê™¢Ê∏¨‰ΩøÁî®Ëº™Ë©¢ÊñπÂºèÈÄ≤Ë°åÊ™¢Ê∏¨ÔºåÂÉÖËÉΩÂú® Systick‰∏≠Êñ∑ÂÖßË™øÁî®„ÄÇ
  94            * @retval        ÁÑ°
  95            */
  96          void Fault_Detection(void)
  97          {
  98   1        // ÂáΩÊï∏Âü∑Ë°åÈñãÂßã
  99   1        mcFaultDect.segment++;
 100   1        if(mcFaultDect.segment >= 3)
 101   1        {
C51 COMPILER V9.53.0.0   MOTORPROTECT                                                      04/09/2024 13:54:55 PAGE 3   

 102   2          mcFaultDect.segment = 0;
 103   2        }
 104   1       
 105   1        if(mcFaultDect.segment == 0)
 106   1        {
 107   2          #if (VoltageProtect_Enable == 1)
 108   2          {
 109   3            Fault_OverUnderVoltage();
 110   3          }
 111   2          #endif
 112   2        }
 113   1        else if(mcFaultDect.segment == 1)
 114   1        {
 115   2          #if (StallProtect_Enable == 1)
 116   2          {
 117   3            Fault_Stall();
 118   3          }
 119   2          #endif
 120   2        }
 121   1        else if(mcFaultDect.segment == 2)
 122   1        {
 123   2          #if (PhaseLossProtect_Enable == 1)
 124   2          {
 125   3            Fault_phaseLoss();
 126   3          }
 127   2          #endif
 128   2        }
 129   1        
 130   1        if(mcState == mcFault)
 131   1        {
 132   2          switch(mcFaultSource.Source)
 133   2          {
 134   3            case Hard_OverCurrent:
 135   3            case Soft_OverCurrent:
 136   3            {
 137   4              mcFaultDect.CurrentRecoverCnt++;
 138   4              if(mcFaultDect.CurrentRecoverCnt >= OverCurrentRecoverTime)
 139   4              {
 140   5                BEMFDetect.BEMFBrakeFlag = 0;
 141   5                Open_TailWind_Flag       = 0;                      // Êú™Áü•ËôïÁêÜÈöéÊÆµÔºåË©≤ËÆäÊï∏Â∑≤Âú® Fault
             -Process() ÂáΩÊï∏‰∏≠Ê∏ÖÈô§„ÄÇ
 142   5                Open_TailWind_Count      = 0;                      // Êú™Áü•ËôïÁêÜÈöéÊÆµÔºåË©≤ËÆäÊï∏Â∑≤Âú® Fault
             -Process() ÂáΩÊï∏‰∏≠Ê∏ÖÈô§„ÄÇ
 143   5                mcFaultSource.Source = NoFault;
 144   5                mcFaultDect.CurrentRecoverCnt  = 0;
 145   5              }
 146   4              break;
 147   4            }
 148   3            case SPD_Es_compMethod:
 149   3            case StartTimOUT_Method:
 150   3            case OUTOfRange_Method:
 151   3            {
 152   4              if (mcFaultDect.StallReCount != 0)
 153   4                mcFaultDect.StallReCount--;
 154   4              
 155   4              #if (Stall_retryStart_Enable == 1)
                      {
                        if (Stall_retryCounter < Stall_retryStart_Count && STall_retryIdle_Flag == 0)
                        {
                          Stall_retryCounter++;
                          mcFaultDect.StallReCount = 0;
                        }
C51 COMPILER V9.53.0.0   MOTORPROTECT                                                      04/09/2024 13:54:55 PAGE 4   

                        else
                        {
                          STall_retryIdle_Flag = 1;
                        }
                      }
                      #endif
 168   4              
 169   4              if(mcFaultDect.StallReCount == 0)
 170   4              {
 171   5                #if (Stall_retryStart_Enable == 1)
                        {
                          STall_retryIdle_Flag = 0;
                        }
                        #endif
 176   5                
 177   5                mcFaultSource.Source = NoFault;
 178   5                Open_TailWind_Flag       = 0;                      // Êú™Áü•ËôïÁêÜÈöéÊÆµÔºåË©≤ËÆäÊï∏Â∑≤Âú® Fault
             -Process() ÂáΩÊï∏‰∏≠Ê∏ÖÈô§„ÄÇ
 179   5                Open_TailWind_Count      = 0;                      // Êú™Áü•ËôïÁêÜÈöéÊÆµÔºåË©≤ËÆäÊï∏Â∑≤Âú® Fault
             -Process() ÂáΩÊï∏‰∏≠Ê∏ÖÈô§„ÄÇ
 180   5              }
 181   4              break;
 182   4            }
 183   3            case PhaseLoss:
 184   3            {
 185   4              if((mcProtectTime.LossPHTimes < 5) && PhaseLossRecoverTime > 0)
 186   4              {
 187   5                mcFaultDect.mcLossPHRecCount++;
 188   5                if(mcFaultDect.mcLossPHRecCount >= PhaseLossRecoverTime)
 189   5                {
 190   6                  mcFaultDect.AOpencnt = 0;
 191   6                  mcFaultDect.BOpencnt = 0;
 192   6                  mcFaultDect.COpencnt = 0;
 193   6                  mcFaultSource.Source = NoFault;
 194   6                }
 195   5              }
 196   4              else
 197   4              {
 198   5                mcFaultDect.mcLossPHRecCount = 0;
 199   5              }
 200   4              break;
 201   4            }
 202   3            case UnderVoltage:
 203   3            case OverVoltage: 
 204   3            {
 205   4              if((ADCSampling.DcBus_Flt < Volt2DcBus(Over_Recover_Voltage)) && (ADCSampling.DcBus_Flt > Volt2DcB
             -us(Under_Recover_Voltage)))
 206   4              {
 207   5                mcFaultDect.VoltRecoverCnt++;
 208   5                if(mcFaultDect.VoltRecoverCnt > OverVlotageRecoverTime)
 209   5                {
 210   6                  mcFaultDect.StallSpeedAndEsCnt = 0;              // Êú™Áü•ËôïÁêÜÈöéÊÆµÔºåË©≤ËÆäÊï∏Ê∏ÖÈô§ËàáÂê¶
             -Ôºå‰∏çË∂≥‰ª•ÂΩ±ÈüøÈõªÊ©üÈÅãË°å„ÄÇ
 211   6                  mcFocCtrl.State_Count          = 100;
 212   6                  Open_TailWind_Flag             = 0;              // Êú™Áü•ËôïÁêÜÈöéÊÆµÔºåË©≤ËÆäÊï∏Â∑≤Âú® Fault
             -Process() ÂáΩÊï∏‰∏≠Ê∏ÖÈô§„ÄÇ
 213   6                  Open_TailWind_Count            = 0;              // Êú™Áü•ËôïÁêÜÈöéÊÆµÔºåË©≤ËÆäÊï∏Â∑≤Âú® Fault
             -Process() ÂáΩÊï∏‰∏≠Ê∏ÖÈô§„ÄÇ
 214   6                  mcFaultSource.Source = NoFault;
 215   6                  mcFaultDect.VoltRecoverCnt     = 0;
 216   6                }
 217   5              }
C51 COMPILER V9.53.0.0   MOTORPROTECT                                                      04/09/2024 13:54:55 PAGE 5   

 218   4              break;
 219   4            }
 220   3          } 
 221   2        }
 222   1        
 223   1        #if (Stall_retryStart_Enable == 1)
                {
                  if (mcFocCtrl.Millis > 1000)
                  {
                    STall_retryIdle_Flag = 1;
                  }
                  
                  if (STall_retryIdle_Flag == 1 && Stall_retryCounter != 0)
                  {
                    Stall_retryCounter = 0;
                  }
                }
                #endif
 236   1        // ÂáΩÊï∏Âü∑Ë°åÁµêÊùü
 237   1      }
 238          
 239          
 240          /**
 241            * @brief         Â†µËΩâÊ™¢Ê∏¨ÂáΩÊï∏
 242            * @detail        Â†µËΩâ‰øùË≠∑Ê™¢Ê∏¨Áõ∏Èóú„ÄÇ @note Êú¨ÂáΩÊï∏ÂÉÖËÉΩÂú® Fault_Detection() ÂáΩÊï∏‰∏≠Ë¢´Ë™øÁ
             -î®„ÄÇ
 243            * @retval        ÁÑ°
 244            */
 245          void Fault_Stall(void)
 246          {
 247   1        // ÂáΩÊï∏Âü∑Ë°åÈñãÂßã
 248   1        if(BEMFDetect.BEMF_Inverse_Current_Flag == 1)
 249   1        {
 250   2          Stall_CCW_State_Count = 400;
 251   2        }
 252   1        else
 253   1        {
 254   2          Stall_CCW_State_Count = 180;
 255   2        }
 256   1        
 257   1        if((mcState == mcRun) && (mcFocCtrl.Open_DCBus_RetryFlag == 0))
 258   1        {
 259   2          if(mcFaultDect.StallDelayCnt <= Stall_CCW_State_Count)
 260   2          {
 261   3            mcFaultDect.StallDelayCnt++;
 262   3          }
 263   2          else
 264   2          {
 265   3            /** Ê¢ù‰ª∂1 MODE0 ÊôÇÈñìÈÄæÊôÇ **/
 266   3            if (mcFocCtrl.CtrlMode == 0)
 267   3            {
 268   4              mcFaultDect.StartFocmode++;
 269   4              if (mcFaultDect.StartFocmode > Stall_ATOEndTime)
 270   4              {
 271   5                #if (Stall_Diff_RecoverTime_En == 0)
 272   5                {
 273   6                  mcFaultDect.StallReCount = StallRecoverTime;
 274   6                }
 275   5                #elif (Stall_Diff_RecoverTime_En == 1)
                        {
                          mcFaultDect.StallReCount = (StallRecoverTime + 500);
                        }
C51 COMPILER V9.53.0.0   MOTORPROTECT                                                      04/09/2024 13:54:55 PAGE 6   

                        #endif
 280   5                
 281   5                mcFaultDect.StartFocmode = 0;
 282   5                mcFaultSource.Source = StartTimOUT_Method;
 283   5            mcFocCtrl.FaultStopFlag = 0;
 284   5              }
 285   4            }
 286   3            else
 287   3            {
 288   4              mcFaultDect.StartFocmode = 0;
 289   4            }
 290   3            
 291   3            /** Ê¢ù‰ª∂2 FOC__UQ Ê∫¢‰Ωç **/
 292   3            if(FOC__UQ < 500)
 293   3            {
 294   4              mcFaultDect.FOCUQ_Stall_Count++;
 295   4              if(mcFaultDect.FOCUQ_Stall_Count > 20)
 296   4              {
 297   5                
 298   5                #if (Stall_Diff_RecoverTime_En == 0)
 299   5                {
 300   6                  mcFaultDect.StallReCount = StallRecoverTime;
 301   6                }
 302   5                #elif (Stall_Diff_RecoverTime_En == 1)
                        {
                          mcFaultDect.StallReCount = (StallRecoverTime + 750);
                        }
                        #endif
 307   5                
 308   5                mcFaultDect.FOCUQ_Stall_Count = 0;
 309   5                mcFaultSource.Source = UQOverFlow_Method;
 310   5            mcFocCtrl.FaultStopFlag = 0;
 311   5              }
 312   4            }
 313   3            else
 314   3            {
 315   4              mcFaultDect.FOCUQ_Stall_Count = 0;
 316   4            }
 317   3            
 318   3            /** Ê¢ù‰ª∂3 ÈõªÊ©ü‰º∞ÁÆóÂ§±ÈÄü **/
 319   3            if((mcFocCtrl.SpeedFlt < Motor_Stall_Min_Speed) || (mcFocCtrl.SpeedFlt > Motor_Stall_Max_Speed))
 320   3            {
 321   4              mcFaultDect.StallDectSpeed++;
 322   4              if(mcFaultDect.StallDectSpeed >=5)
 323   4              {
 324   5                #if (Stall_Diff_RecoverTime_En == 0)
 325   5                {
 326   6                  mcFaultDect.StallReCount = StallRecoverTime;
 327   6                }
 328   5                #elif (Stall_Diff_RecoverTime_En == 1)
                        {
                          mcFaultDect.StallReCount = (StallRecoverTime + 248);
                        }
                        #endif
 333   5                
 334   5                mcFaultDect.StallDectSpeed = 0;
 335   5                mcFaultSource.Source = SPD_Es_compMethod;
 336   5            mcFocCtrl.FaultStopFlag = 0;
 337   5              }
 338   4            }
 339   3            else if (mcFaultDect.StallDectSpeed > 0)
 340   3            {
C51 COMPILER V9.53.0.0   MOTORPROTECT                                                      04/09/2024 13:54:55 PAGE 7   

 341   4              mcFaultDect.StallDectSpeed--;
 342   4            }
 343   3            
 344   3            /** Ê¢ù‰ª∂4 ÈõªÊ©ü‰º∞ÁÆóËΩâÈÄüËàáÂèçÈõªÂãïÂã¢Áï∞Â∏∏ **/
 345   3            if(mcFocCtrl.SpeedFlt > (((uint32)mcFocCtrl.EsValue) * 3))
 346   3            {
 347   4              mcFaultDect.StallSpeedAndEsCnt++;
 348   4              if(mcFaultDect.StallSpeedAndEsCnt >= StallSensitivity)
 349   4              {
 350   5                #if (Stall_Diff_RecoverTime_En == 0)
 351   5                {
 352   6                  mcFaultDect.StallReCount = StallRecoverTime;
 353   6                }
 354   5                #elif (Stall_Diff_RecoverTime_En == 1)
                        {
                          mcFaultDect.StallReCount = (StallRecoverTime + 0);
                        }
                        #endif
 359   5                
 360   5                mcFaultDect.StallSpeedAndEsCnt = 0;
 361   5                mcFaultSource.Source = OUTOfRange_Method;
 362   5            mcFocCtrl.FaultStopFlag = 0;
 363   5              }
 364   4            }
 365   3            else if(mcFaultDect.StallSpeedAndEsCnt > 0)
 366   3            {
 367   4              mcFaultDect.StallSpeedAndEsCnt--;
 368   4            }
 369   3          }
 370   2        }
 371   1        // ÂáΩÊï∏Âü∑Ë°åÁµêÊùü
 372   1      }
 373          
 374          
 375          /**
 376            * @brief         ÈÅéÊ¨†ÈõªÂ£ìÊ™¢Ê∏¨ÂáΩÊï∏
 377            * @detail        ÈÅéÊ¨†ÈõªÂ£ìÊ™¢Ê∏¨Áõ∏Èóú„ÄÇ @note Êú¨ÂáΩÊï∏ÂÉÖËÉΩÂú® Fault_Detection() ÂáΩÊï∏‰∏≠Ë¢´Ë™øÁ
             -î®„ÄÇ
 378            * @retval ÁÑ°
 379            */
 380          void Fault_OverUnderVoltage(void)
 381          {
 382   1        static uint8 UV_CNT = 5, OV_CNT = 5;
 383   1        // ÂáΩÊï∏Âü∑Ë°åÈñãÂßã
 384   1        if((mcFaultSource.Source == NoFault))
 385   1        {
 386   2          if (ADCSampling.DcBus_Flt > Volt2DcBus(Over_Protect_Voltage) || (mcState == mcReady && (ADCSampling.Dc
             -Bus_Flt > Volt2DcBus(Over_Recover_Voltage))))
 387   2          {
 388   3            UV_CNT = 5;
 389   3            if (OV_CNT != 0)
 390   3              OV_CNT--;
 391   3            else
 392   3            {
 393   4              mcFaultSource.Source = OverVoltage;
 394   4          mcFocCtrl.FaultStopFlag = 0;
 395   4            }
 396   3          }
 397   2          else if (ADCSampling.DcBus_Flt < Volt2DcBus(Under_Protect_Voltage) || (mcState == mcReady && (ADCSampl
             -ing.DcBus_Flt < Volt2DcBus(Under_Recover_Voltage))))
 398   2          {
 399   3            OV_CNT = 5;
C51 COMPILER V9.53.0.0   MOTORPROTECT                                                      04/09/2024 13:54:55 PAGE 8   

 400   3            if (UV_CNT != 0)
 401   3              UV_CNT--;
 402   3            else
 403   3            {
 404   4              mcFaultSource.Source = UnderVoltage;
 405   4          mcFocCtrl.FaultStopFlag = 0;
 406   4            }
 407   3          }
 408   2          else
 409   2          {
 410   3            UV_CNT = 5;
 411   3            OV_CNT = 5;
 412   3          }
 413   2        }  
 414   1        // ÂáΩÊï∏Âü∑Ë°åÁµêÊùü
 415   1      }
 416          
 417          
 418          /**
 419            * @brief         Ê¨†Áõ∏‰øùË≠∑Ê™¢Ê∏¨ÂáΩÊï∏
 420            * @detail        Ê¨†Áõ∏Ê™¢Ê∏¨Áõ∏Èóú„ÄÇ @note Êú¨ÂáΩÊï∏ÂÉÖËÉΩÂú® Fault_Detection() ÂáΩÊï∏‰∏≠Ë¢´Ë™øÁî®„ÄÇ
 421            * @retval        ÁÑ°
 422            */
 423          void Fault_phaseLoss(void)
 424          {
 425   1        // ÂáΩÊï∏Âü∑Ë°åÈñãÂßã
 426   1        if(mcState == mcRun)
 427   1        {
 428   2          mcFaultDect.Lphasecnt++;
 429   2          if(mcFaultDect.Lphasecnt > 20)
 430   2          {
 431   3            mcFaultDect.Lphasecnt = 0;
 432   3            if(((mcCurVarible.Max_ia > (mcCurVarible.Max_ib * 2)) || (mcCurVarible.Max_ia > (mcCurVarible.Max_ic
             - * 2)))
 433   3                && (mcCurVarible.Max_ia > PhaseLossCurrentValue))
 434   3            {
 435   4              mcFaultDect.AOpencnt++;
 436   4            }
 437   3            else if(mcFaultDect.AOpencnt > 0)
 438   3            {
 439   4              mcFaultDect.AOpencnt--;
 440   4            }
 441   3      
 442   3            if(((mcCurVarible.Max_ib > (mcCurVarible.Max_ia * 2)) || (mcCurVarible.Max_ib > (mcCurVarible.Max_ic
             - * 2)))
 443   3                && (mcCurVarible.Max_ib > PhaseLossCurrentValue))
 444   3            {
 445   4              mcFaultDect.BOpencnt++;
 446   4            }
 447   3            else if(mcFaultDect.BOpencnt > 0)
 448   3            {
 449   4               mcFaultDect.BOpencnt--;
 450   4            }
 451   3      
 452   3            if(((mcCurVarible.Max_ic > (mcCurVarible.Max_ia * 2)) || (mcCurVarible.Max_ic > (mcCurVarible.Max_ib
             - * 2)))
 453   3                && (mcCurVarible.Max_ic > PhaseLossCurrentValue))
 454   3            {
 455   4              mcFaultDect.COpencnt++;
 456   4            }
 457   3            else if(mcFaultDect.COpencnt > 0) 
 458   3            {
C51 COMPILER V9.53.0.0   MOTORPROTECT                                                      04/09/2024 13:54:55 PAGE 9   

 459   4              mcFaultDect.COpencnt--;
 460   4            }
 461   3            
 462   3            mcCurVarible.Max_ia = 0;
 463   3            mcCurVarible.Max_ib = 0;
 464   3            mcCurVarible.Max_ic = 0;
 465   3            SetBit(FOC_CR2, ICLR);
 466   3            if((mcFaultDect.AOpencnt > 9) || (mcFaultDect.BOpencnt > 9) || (mcFaultDect.COpencnt > 9))
 467   3            {
 468   4              mcProtectTime.LossPHTimes++;
 469   4              mcFaultSource.Source = PhaseLoss;
 470   4          mcFocCtrl.FaultStopFlag = 0;
 471   4            }
 472   3          }
 473   2        }
 474   1        // ÂáΩÊï∏Âü∑Ë°åÁµêÊùü
 475   1      }
 476          
 477          
 478          /**
 479            * @brief         ËªüÈ´îÈÅéÈõªÊµÅÊ™¢Ê∏¨ÂáΩÊï∏
 480            * @detail        ËªüÈ´îÈÅéÈõªÊµÅÊ™¢Ê∏¨Áõ∏ÈóúÂáΩÊï∏„ÄÇ @note Êú¨ÂáΩÊï∏ÂÉÖËÉΩÂú® DRV_ISR() ‰∏≠Êñ∑ÂáΩÊï∏‰∏≠
             -Ë¢´Ë™øÁî®„ÄÇ
 481            * @param[in,out] CurrentVarible *h_Cur  FOCÈõªÊµÅÊé°ÈõÜËÆäÊï∏
 482            * @retval        ÁÑ°
 483            */
 484          void Fault_softOverCurrent(CurrentVarible *h_Cur)
 485          {
 486   1        // ÂáΩÊï∏Âü∑Ë°åÈñãÂßã
 487   1        if((mcState == mcRun) || (mcState == mcStart))
 488   1        {
 489   2          h_Cur->Max_ia = FOC__IAMAX;
 490   2          h_Cur->Max_ib = FOC__IBMAX;
 491   2          h_Cur->Max_ic = FOC__ICMAX;
 492   2      
 493   2          mcCurVarible.Max_ia = FOC__IAMAX;
 494   2          mcCurVarible.Max_ib = FOC__IBMAX;
 495   2          mcCurVarible.Max_ic = FOC__ICMAX;
 496   2      
 497   2          if((FOC__IAMAX >= OverSoftCurrentValue) || (FOC__IBMAX >= OverSoftCurrentValue) || (FOC__ICMAX >= Over
             -SoftCurrentValue))
 498   2          {
 499   3            h_Cur->OverCurCnt++;
 500   3            if(h_Cur->OverCurCnt >= 3)
 501   3            {
 502   4              mcFaultSource.Source = Soft_OverCurrent;
 503   4          mcFocCtrl.FaultStopFlag = 0;
 504   4              h_Cur->Max_ia     = 0;
 505   4              h_Cur->Max_ib     = 0;
 506   4              h_Cur->Max_ic     = 0;
 507   4              h_Cur->OverCurCnt = 0;
 508   4            }
 509   3          }
 510   2          else if (h_Cur->OverCurCnt > 0)
 511   2          {
 512   3            h_Cur->OverCurCnt--;
 513   3          }
 514   2        }
 515   1        // ÂáΩÊï∏Âü∑Ë°åÁµêÊùü
 516   1      }
 517          
 518          
C51 COMPILER V9.53.0.0   MOTORPROTECT                                                      04/09/2024 13:54:55 PAGE 10  

 519          /**
 520            * @brief         Áï∞Â∏∏ËôïÁêÜÂáΩÊï∏
 521            * @detail        ÈõªÊ©ü‰øùË≠∑Êé•ÊÆµÁõ∏ÈóúËôïÁêÜ„ÄÇ
 522            * @retval        ÁÑ°
 523            */
 524          void FaultProcess(void)
 525          {
 526   1        // ÂáΩÊï∏Âü∑Ë°åÈñãÂßã
 527   1        /** ÈóúÈñâÈõªÊ©üËº∏Âá∫ --ÈñãÂßã **/
 528   1        ClrBit(DRV_CR, DRVEN);
 529   1        ClrBit(DRV_CR, FOCEN);
 530   1        MOE     = 0;
 531   1      //  mcState = mcFault;
 532   1        /** ÈóúÈñâÈõªÊ©üËº∏Âá∫ --ÁµêÊùü **/
 533   1      
 534   1        /** ÂÖ∂‰ªñËôïÁêÜÁ®ãÂ∫è --ÈñãÂßã **/
 535   1        #if (ROTATESIGNAL_TYPE == RD_TYPE)
                {
              //    RDFault_Detection();
                }
                #endif
 540   1        
 541   1        mcFocCtrl.CtrlMode  = 0;
 542   1        Open_TailWind_Flag  = 0;
 543   1        Open_TailWind_Count = 0;
 544   1        /** ÂÖ∂‰ªñËôïÁêÜÁ®ãÂ∫è --ÁµêÊùü **/
 545   1        // ÂáΩÊï∏Âü∑Ë°åÁµêÊùü
 546   1      }
 547          


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   1535    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =      8    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =     32    ----
   BIT SIZE         =   ----    ----
   EDATA SIZE       =   ----    ----
   HDATA SIZE       =   ----    ----
   XDATA CONST SIZE =   ----    ----
   FAR CONST SIZE   =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
